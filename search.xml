<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARTS-01</title>
    <url>/2019/06/30/ARTS-01/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>Two Sum 两数之和（leetcode #1）</p>
<p>“平生不识 TwoSum，刷尽 LeetCode 也枉然。”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span><br><span class="line"></span><br><span class="line">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：<br>本题的要求是找到两数之和等于 target 的以这两个数的下表为元素的数组，初步的想法应该用HashMap 存下遍历 nums数组的下表与对应的值，并且判断当 用target减去 已存在的数得到数组中另一个数时，满足题目的要求，返回他们的下标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        int[] result &#x3D; new int[2];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[0] &#x3D; map.get(target - nums[i]);</span><br><span class="line">                result[1] &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><strong>Top Signs of an Over-Experienced Programmer</strong><br><a href="https://medium.com/better-programming/top-signs-of-an-over-experienced-programmer-22bbe0b57663" target="_blank" rel="noopener">https://medium.com/better-programming/top-signs-of-an-over-experienced-programmer-22bbe0b57663</a></p>
<p>只要我们还是programmer 我们的重心还是要放到programming 与 engineering 上，过度地考虑需求是否合理，项目是否能满足用户需求等并不是我们需要考虑的重心。我们需要避免不必要的refactoring，以尽可能perfect地实现需求为目标，深入到code engineering才是。</p>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p><strong>本周在做新项目时又重新用到了 hibernate mybatis 和 jdbcTemplate。下面针对这些工具我个人的一些看法</strong></p>
<ul>
<li>hibernate 虽然比较方便，结合Spring Data JPA 可以非常方便的写出crud逻辑，但缺点也非常明显，就是相对其他两个来说太不灵活了，如果不小心开启了自动生成数据库的配置，自动生成的外键够让你难受的了。</li>
<li>mybatis 使用起来中规中矩，但还是不够灵活，仿佛掉进了维护数据表间关系的坑里。</li>
<li>jdbcTemplate 我用得最顺手，特别是 NamedParameterJdbcTemplate，通过手动拼接SQL实现复杂的逻辑非常好用，还不必像在PreparedStatement中一样数问号🤣</li>
</ul>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p><strong>本周分享的文章是来自 阿里云云栖社区 的一篇关于HashMap的文章</strong><br>由阿里巴巴Java开发规约HashMap条目引发的故事<br><a href="https://zhuanlan.zhihu.com/p/30360734" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30360734</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-02.md</title>
    <url>/2019/07/14/ARTS-02/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>Print in Order（1114）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Suppose we have a class:</span><br><span class="line"></span><br><span class="line">public class Foo &#123;</span><br><span class="line">  public void one() &#123; print(&quot;one&quot;); &#125;</span><br><span class="line">  public void two() &#123; print(&quot;two&quot;); &#125;</span><br><span class="line">  public void three() &#123; print(&quot;three&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">The same instance of Foo will be passed to three different threads. Thread A will call one(), thread B will call two(), and thread C will call three(). Design a mechanism and modify the program to ensure that two() is executed after one(), and three() is executed after two().</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;print-in-order</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong>：<br>leetcode关于多线程的新题，考察多线程中的按序执行。<br>可以用以下方法解：</p>
<ol>
<li>利用CountDownLatch 来控制执行的顺序。</li>
<li>利用volatile 创建全局可见的变量，通过对该变量的原子性更新来保证执行顺序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">    private CountDownLatch c2;</span><br><span class="line">    private CountDownLatch c3;</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        c2 &#x3D; new CountDownLatch(1);</span><br><span class="line">        c3 &#x3D; new CountDownLatch(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">        printFirst.run();</span><br><span class="line">        c2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        c2.await();</span><br><span class="line">        &#x2F;&#x2F; printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        printSecond.run();</span><br><span class="line">        c3.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        c3.await();</span><br><span class="line">        &#x2F;&#x2F; printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile int flag &#x3D; 1;</span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">        printFirst.run();</span><br><span class="line">        flag &#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        while(flag !&#x3D; 2);</span><br><span class="line">        &#x2F;&#x2F; printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        printSecond.run();</span><br><span class="line">        flag &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        while(flag !&#x3D; 3);</span><br><span class="line">        &#x2F;&#x2F; printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><strong>Faircode, an alternative to Open Source that aims to get developers paid</strong><br><a href="https://hackernoon.com/faircode-an-alternative-to-open-source-89cdc65df3fa" target="_blank" rel="noopener">https://hackernoon.com/faircode-an-alternative-to-open-source-89cdc65df3fa</a></p>
<p>在2017年作者提出了Faircode这个概念，旨在给开发者一个新的盈利方式。不同于“闭源软件”，Faircode 打算以向大公司收费而对小公司免费的形势获利。然而不幸的是，作者发起的Faircode 及相关的license 已经被删除了。作者想法在当时比较前卫，可能在推行的过程中成效不大吧。</p>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p><a href="https://javarevisited.blogspot.com/2018/05/10-tips-to-become-better-java-developer.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2018/05/10-tips-to-become-better-java-developer.html</a></p>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>JAVA 注解的基本原理</p>
<p><a href="https://juejin.im/post/5b45bd715188251b3a1db54f" target="_blank" rel="noopener">https://juejin.im/post/5b45bd715188251b3a1db54f</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-03</title>
    <url>/2019/07/26/ARTS-03/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>Add Two Numbers(#2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;2 lang&#x3D;java</span><br><span class="line"> *</span><br><span class="line"> * [2] 两数相加</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode pre &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; pre;</span><br><span class="line">        int carry &#x3D; 0;</span><br><span class="line">        while (l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            int x &#x3D; l1 &#x3D;&#x3D; null ? 0 : l1.val;</span><br><span class="line">            int y &#x3D; l2 &#x3D;&#x3D; null ? 0 : l2.val;</span><br><span class="line">            int sum &#x3D; x + y + carry;</span><br><span class="line">            </span><br><span class="line">            carry &#x3D; sum &#x2F; 10;</span><br><span class="line">            sum &#x3D; sum % 10;</span><br><span class="line">            cur.next &#x3D; new ListNode(sum);</span><br><span class="line"></span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">            if (l1 !&#x3D; null) &#123;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (l2 !&#x3D; null) &#123;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            cur.next &#x3D; new ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        return pre.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题我们可以创建一个辅助节点pre 再用一个节点cur指向我们正在进行计算的结果链表上的节点。</p>
<p>通过对l1, l2这两条链做遍历，我们可以获得l1, l2 当前节点的值x 和 y，可以计算出他们与进位标识（变量carry，初始值为0）的和sum。可以通过对carry被10整除的余数来得知当前节点的两数相加是否进位。通过对sum的值对10取mod，可以得到加了进位后的值。</p>
<p>之后就是创建辅助节点链的后一个节点，并把cur指向新节点。如果这次运算有进位，则再新增一个值为carry的节点。 这样重复直到l1 或 l2到达链尾，如果不同时到达链尾，则结果链表依次把未到达链尾的数复制，最后l1，l2都到达链尾，计算结束。</p>
<h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><strong>Python at Netflix</strong></p>
<p><a href="https://medium.com/netflix-techblog/python-at-netflix-bba45dae649e" target="_blank" rel="noopener">https://medium.com/netflix-techblog/python-at-netflix-bba45dae649e</a></p>
<p>这篇文章主要介绍了Python在Netflix技术架构中的应用。给想要用Python搞事情的朋友们一些有事实支持的思路。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>本周分享一下Java内存模型的happen before原则</p>
<ol>
<li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作happens before于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。如果在一个线程的操作，那么前一个操作的结果必定对后续操作可见。</li>
<li>管程锁定规则：一个unlock操作happens before于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。最常见的就是syncronized 方法和syncronized代码块。</li>
<li>volatile变量规则：对一个volatile变量的写操作happens before于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。该规则在ConcurrentHashMap 中读操作不需要加锁中有很好的体现。</li>
<li>线程启动规则：Thread对象的start()方法happens before于此线程的每一个动作。</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</li>
</ol>
<p>传递性：如果 A happens before B，且B happens before C，则A happens before C</p>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>打造 Mac 下高颜值好用的终端环境</p>
<p><a href="https://blog.biezhi.me/2018/11/build-a-beautiful-mac-terminal-environment.html" target="_blank" rel="noopener">https://blog.biezhi.me/2018/11/build-a-beautiful-mac-terminal-environment.html</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-04</title>
    <url>/2019/08/02/ARTS-04/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>无重复字符的最长子串(3)</p>
<p><strong>解法1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=3 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [3] 无重复字符的最长子串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= l; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allUnique(s, i, j)) &#123;</span><br><span class="line">                    result = Math.max(result, j - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            Character c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(c)) &#123;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力破解法没啥好说的, 直接超时了, 显然是不可行的.<br>时间复杂度：O(n^3)</p>
<p><strong>解法2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中接口与抽象类的区别</title>
    <url>/2019/07/02/Java-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>如果一个类有抽象方法，则称这个类为抽象类。使用abstract修饰抽象类。<br>抽象类中可能含有无具体实现的方法，故不能用抽象类创建对象。抽象方法是一种特殊的方法，只有声明，没有实现。如果一个类继承抽象类，则必须实现父类的抽象方法，如果不这么做，则此类也应该为抽象类。</p>
<h5 id="抽象类与普通类的区别"><a href="#抽象类与普通类的区别" class="headerlink" title="抽象类与普通类的区别"></a>抽象类与普通类的区别</h5><ol>
<li>抽象方法的访问修饰符必须为public 或者 protected（如果为private 则不能被子类继承，子类无法实现该方法），默认为public。</li>
<li>抽象类不能用来创建对象。</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的所有抽象方法。如果子类没有实现，则必须定义为abstract class。</li>
</ol>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>可以含有变量和方法。<br>但是接口中非default的方法是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract（1.8以后可以是default），其他修饰符都会报错）。<br>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</p>
<h5 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h5><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。(Java 1.8以后接口可以有可以实现的default方法)</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Exception &amp; Error</title>
    <url>/2019/05/22/Java-Exception-Error/</url>
    <content><![CDATA[<p>###java.lang.ClassNotFoundException</p>
<p>This exception indicates that the class was not found on the classpath. This indicates that we were trying to load the class definition, and the class did not exist on the classpath.</p>
<p>###java.lang.NoClassDefFoundError<br>This exception indicates that the JVM looked in its internal class definition data structure for the definition of a class and did not find it. This is different than saying that it could not be loaded from the classpath. Usually this indicates that we previously attempted to load a class from the classpath, but it failed for some reason - now we’re trying to use the class again (and thus need to load it, since it failed last time), but we’re not even going to try to load it, because we failed loading it earlier (and reasonably suspect that we would fail again). The earlier failure could be a ClassNotFoundException or an ExceptionInInitializerError (indicating a failure in the static initialization block) or any number of other problems. The point is, a NoClassDefFoundError is not necessarily a classpath problem.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis八股文</title>
    <url>/2020/09/03/Redis%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h2 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h2><ol>
<li>Redis 有哪些数据结构，分别有什么使用场景？</li>
<li>Redis ZSET 相同 score 如何排序？</li>
<li>在爬虫中，如何使用 Redis 做 URL 去重？</li>
<li>Redis 是否支持事务？</li>
<li>Redis 中的 WATCH 命令是做什么的？</li>
<li>Redis 是如何保证高可用的？</li>
<li>如何使用 Redis 来实现分布式锁？Redlock？</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（二）divide, rewrite 插件</title>
    <url>/2021/01/16/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89divide-rewrite-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一节里我们编译好了 Soul 网关的源码，今天我们从rewrite插件开始学习如何对服务进行代理并重写路径。</p>
<a id="more"></a>

<p>首先我们用Python写一个简单的Flask应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/foo/bar/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>启动服务后，我们可以看到现在设置的路径为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;foo&#x2F;bar&#x2F;</span><br></pre></td></tr></table></figure>
<p>尝试使用 curl 访问对应的接口：<br><img src="https://img-blog.csdnimg.cn/20210115211421555.png" alt="在这里插入图片描述"><br>OK，服务正常。</p>
<p>我们在 soul-admin 选择 <strong>rewrite</strong> 插件，点击添加选择器：<br><img src="https://img-blog.csdnimg.cn/20210115210809657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="选择添加选择器"><br>在弹出的对话框中输入：<br><img src="https://img-blog.csdnimg.cn/20210115211626802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击确认后，通过 Chrome debug 可以捕获到前端发起的三个请求，分别是：</p>
<ol>
<li>/selector</li>
<li>/selector?pluginId=3&amp;currentPage=1&amp;pageSize=12</li>
<li>/rule?currentPage=1&amp;pageSize=12&amp;selectorId=1350069791219036160</li>
</ol>
<p>我们追踪到对应的源码可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * query Selectors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pluginId    plugin id.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentPage current page.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize    page size.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@linkplain</span> SoulAdminResult&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SoulAdminResult <span class="title">querySelectors</span><span class="params">(<span class="keyword">final</span> String pluginId, <span class="keyword">final</span> Integer currentPage, <span class="keyword">final</span> Integer pageSize)</span> </span>&#123;</span><br><span class="line">    CommonPager&lt;SelectorVO&gt; commonPager = selectorService.listByPage(<span class="keyword">new</span> SelectorQuery(pluginId, <span class="keyword">new</span> PageParameter(currentPage, pageSize)));</span><br><span class="line">    <span class="keyword">return</span> SoulAdminResult.success(SoulResultMessage.QUERY_SUCCESS, commonPager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两个请求其实是在加载我们右侧的选择器，现在我们没有创建选择器，所以什么也没有。<br>而 /rule 这个请求是在查询现有的规则列表。</p>
<p>点击右侧的“创建选择器”按钮来创建选择器：<br><img src="https://img-blog.csdnimg.cn/20210115213000568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建好选择器后，由于我们仅仅是把选择器的数据存放在了 数据库中（根据你配置可能在 MySQL 或 H2里），我们如果需要他即时生效需要点击同步自定义rewrite。<br><img src="https://img-blog.csdnimg.cn/20210115213237513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接口调用路径是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9095&#x2F;plugin&#x2F;syncPluginData&#x2F;3</span><br></pre></td></tr></table></figure>
<p>返回 “sync success”，我们再次切换到源码：<br><img src="https://img-blog.csdnimg.cn/20210115213635126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现 soul-admin 用到了Spring 中的 ApplicationEventPublisher，在如下路径的类中，我们也找到了soul-admin处理这些时间的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org&#x2F;dromara&#x2F;soul&#x2F;admin&#x2F;listener&#x2F;DataChangedEventDispatcher.java</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210115214219112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>刚刚我们应该是通过点击按钮触发了 “onPluginChanged” 这个事件，可以看到，根据我们所配置的数据同步侧录额，soul 提供了三种实现方式：<br><img src="https://img-blog.csdnimg.cn/20210115214458570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p>WebSocket<br> 在 WebsocketDataChangedListener 中调用 onPluginChanged 方法来向 SoulBootstrapApplication 发送JSON序列化后的消息。</p>
</li>
<li><p>Nacos<br> 如果配置 Nacos 进行同步，则是通过 ConfigService 来发送消息。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">     updatePluginMap(getConfig(PLUGIN_DATA_ID));</span><br><span class="line">     <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">         <span class="keyword">case</span> DELETE:</span><br><span class="line">             changed.forEach(plugin -&gt; PLUGIN_MAP.remove(plugin.getName()));</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> REFRESH:</span><br><span class="line">         <span class="keyword">case</span> MYSELF:</span><br><span class="line">             Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(PLUGIN_MAP.keySet());</span><br><span class="line">             changed.forEach(plugin -&gt; &#123;</span><br><span class="line">                 set.remove(plugin.getName());</span><br><span class="line">                 PLUGIN_MAP.put(plugin.getName(), plugin);</span><br><span class="line">             &#125;);</span><br><span class="line">             PLUGIN_MAP.keySet().removeAll(set);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             changed.forEach(plugin -&gt; PLUGIN_MAP.put(plugin.getName(), plugin));</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     publishConfig(PLUGIN_DATA_ID, PLUGIN_MAP);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ZooKeeper<br>  通过节点同步数据。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (PluginData data : changed) &#123;</span><br><span class="line">           <span class="keyword">final</span> String pluginPath = ZkPathConstants.buildPluginPath(data.getName());</span><br><span class="line">           <span class="comment">// delete</span></span><br><span class="line">           <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">               deleteZkPathRecursive(pluginPath);</span><br><span class="line">               <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getName());</span><br><span class="line">               deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">               <span class="keyword">final</span> String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getName());</span><br><span class="line">               deleteZkPathRecursive(ruleParentPath);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//create or update</span></span><br><span class="line">           upsertZkNode(pluginPath, data);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过对指定接口发起 POST 请求来注册其他语言的服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;appName&quot;: &quot;xxx&quot;, &#x2F;&#x2F;应用名称 必填</span><br><span class="line">	&quot;context&quot;: &quot;&#x2F;xxx&quot;, &#x2F;&#x2F;请求前缀 必填</span><br><span class="line">	&quot;path&quot;: &quot;xxx&quot;, &#x2F;&#x2F;路径需要唯一 必填</span><br><span class="line">	&quot;pathDesc&quot;: &quot;xxx&quot;, &#x2F;&#x2F;路径描述</span><br><span class="line">	&quot;rpcType&quot;: &quot;http&quot;, &#x2F;&#x2F;rpc类型  必填</span><br><span class="line">	&quot;host&quot;: &quot;xxx&quot;, &#x2F;&#x2F;服务host 必填</span><br><span class="line">	&quot;port&quot;: xxx, &#x2F;&#x2F;服务端口 必填</span><br><span class="line">	&quot;ruleName&quot;: &quot;xxx&quot;, &#x2F;&#x2F;可以同path一样  必填</span><br><span class="line">	&quot;enabled&quot;: &quot;true&quot;, &#x2F;&#x2F;是否开启</span><br><span class="line">	&quot;registerMetaData&quot;: &quot;true&quot; &#x2F;&#x2F;是否需要注册元数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">请求地址：http:&#x2F;&#x2F;&#123;ip&#125;:&#123;port&#125;&#x2F;soul-client&#x2F;springmvc-register 请自行输入soul-admin 的 IP 和 PORT</span><br></pre></td></tr></table></figure>
<p>在 postman 或其他工具中成功注册服务：<br><img src="https://img-blog.csdnimg.cn/20210116013439579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但我们发现并不能直接通过 soul 来代理我们的 flask 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl http:&#x2F;&#x2F;localhost:9195</span><br><span class="line">&#123;&quot;code&quot;:-107,&quot;message&quot;:&quot;Can not find selector, please check your configuration!&quot;,&quot;data&quot;:null&#125;%</span><br></pre></td></tr></table></figure>
<p>仔细查看文档后，发现需要先设置 Divide 插件并添加对应的selector。<br><img src="https://img-blog.csdnimg.cn/20210116014205816.png" alt="在这里插入图片描述"><br>配置完成后可以看到 divide 插件成功选取到了 我们配置的 test1 selector，但是我们的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:9195&#x2F;foo&#x2F;bar&#x2F;</span><br></pre></td></tr></table></figure>
<p>被解析成了 <a href="http://127.0.0.1:5000/bar/，一定是什么地方出了问题。" target="_blank" rel="noopener">http://127.0.0.1:5000/bar/，一定是什么地方出了问题。</a><br>再看看源码<br><img src="https://img-blog.csdnimg.cn/20210116015548504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们发现 在 org/dromara/soul/plugin/divide/DividePlugin.java 这个类中 buildRealURL 会将我们的 “/foo” 识别为 module，然后把“/bar” 识别为真实的request path，所以导致了刚刚的问题。<br>再次尝试在前面加一层，成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl http:&#x2F;&#x2F;localhost:9195&#x2F;1&#x2F;foo&#x2F;bar&#x2F;</span><br><span class="line">Hello World!%</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js双向数据绑定探究</title>
    <url>/2018/08/03/Vue-js%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在最近的前端面试中，vue.js的双向数据绑定基本是我必问的。下面我们就一起探究下其原理。</p>
<a id="more"></a>

<p><img src="https://i.imgur.com/bKNikGl.jpg" alt=""></p>
<ol>
<li>原理<br>Vue.js双向数据绑定的原理主要是通过 <strong>Object对象的defineProperty方法，重写data的set和get函数</strong> 来实现的。<br>以下是defineProperty()的语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>
这个方法的三个参数分别是：</li>
</ol>
<ul>
<li>obj<br>要在其上定义属性的对象。</li>
<li>prop<br>要定义或修改的属性的名称。</li>
<li>descriptor<br>将被定义或修改的属性描述符。</li>
</ul>
<p>方法相关的就不在这里讨论，详见：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p>
]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>hello_world</title>
    <url>/2018/04/15/hello-world/</url>
    <content><![CDATA[<h4 id="终于有了自己的博客了"><a href="#终于有了自己的博客了" class="headerlink" title="终于有了自己的博客了"></a>终于有了自己的博客了</h4>]]></content>
      <tags>
        <tag>mixture</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql生成批量语句</title>
    <url>/2018/04/28/mysql%E7%94%9F%E6%88%90%E6%89%B9%E9%87%8F%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>今天遇到监控系统的表格太多的问题, 为了节约时间, 在网上找到了生成批量删除表的语句:</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT( &#39;drop table &#39;, table_name, &#39;;&#39; )</span><br><span class="line">FROM information_schema.tables</span><br><span class="line">WHERE table_name LIKE &#39;pre_%&#39;;</span><br></pre></td></tr></table></figure>
<p>这样可以批量生成drop 语句, 使用navicat执行即可.</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h3><p>十分钟了结MySQL information_schema</p>
<p><a href="https://www.cnblogs.com/shengdimaya/p/6920677.html" target="_blank" rel="noopener">https://www.cnblogs.com/shengdimaya/p/6920677.html</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>php 在Windows开发下遇到的坑</title>
    <url>/2018/04/15/php-%E5%9C%A8Windows%E5%BC%80%E5%8F%91%E4%B8%8B%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>在本地调试php通过使用php的curl 调用Thrift rpc 服务时, 使用了curl, 但是一直出现超时的现象,一直到超过请求所附带的超时时间, 这个是因为Windows下的php是以php-cgi进程的形式运行的.</p>
<a id="more"></a>

<p>我的php项目的fastcig-pass的设置为(127.0.0.1:9000)。</p>
<p>默认设置是以keepalive方式请求，接收到PHP文件时,交与php-cgi解析处理,等待响应。</p>
<p>而在本地文件以CURL请求本地环境中PHP文件时,之前的PHP还在等待CURL后的结果，这时9000端口已经被占用.导致CURL一直在处于等待状态.</p>
<p>curl 其中一项设置: </p>
<p>curl_setopt($ch, CURLOPT_TIMEOUT, 5);</p>
<p>当到达5秒后, curl 被强制中断, 反而收到了RPC传来的response</p>
<p>在查阅资料后, 我发现Windows 中php-cgi并不能像Linux环境下的php-fpm 那样自己创建新的进程, 只能通过command的方式启动两个进程…</p>
<p><strong>我的解决方案</strong></p>
<p>把php客户端的fastcgi_pass 设置为了127.0.0.1:9004</p>
<p>打开两个cmd 分别在php根目录下执行这两个命令:</p>
<ol>
<li>php-cgi.exe -b 127.0.0.1:9000 -c php.ini </li>
<li>php-cgi.exe -b 127.0.0.1:9004 -c php.ini </li>
</ol>
<p>但是cmd 命令窗口不能关闭。</p>
<p>问题解决.</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>traps</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（三）dubbo 插件</title>
    <url>/2021/01/17/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89dubbo-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一节中，我们尝试使用divide插件进行http代理，今天我们来看看Soul是如何将http协议，转换成dubbo协议的。</p>
<a id="more"></a>

<p>首先在插件管理中开启dubbo配置：<br><img src="https://img-blog.csdnimg.cn/20210117003330559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开Soul 源码，编译下图路径的dubbo demo 项目：<br><img src="https://img-blog.csdnimg.cn/20210117003428606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>编译后我们把打包好的 Jar 包run起来，<br>确保</p>
<ol>
<li>dubbo 插件已开启</li>
<li>你的soul-bootstrap，soul-admin 在运行状态</li>
<li>zookeeper 也在启动状态（默认端口2181），地址在：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soul&#x2F;soul-examples&#x2F;soul-examples-dubbo&#x2F;soul-examples-alibaba-dubbo-service&#x2F;target&#x2F;soul-examples-alibaba-dubbo-service-2.1.0.jar</span><br></pre></td></tr></table></figure>
成功运行dubbo demo 后，发现soul admin 帮我们注册了其中的 endpoints<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-01-17 00:51:50.563  INFO 63416 --- [-47-EventThread] o.a.c.f.state.ConnectionStateManager     : State change: CONNECTED</span><br><span class="line">2021-01-17 00:51:50.590  INFO 63416 --- [-47-EventThread] o.a.c.framework.imps.EnsembleTracker     : New config event received: &#123;&#125;</span><br><span class="line">2021-01-17 00:51:50.590  INFO 63416 --- [-47-EventThread] o.a.c.framework.imps.EnsembleTracker     : New config event received: &#123;&#125;</span><br><span class="line">2021-01-17 00:51:50.973  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397137501040640, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;insert, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboTestService, methodName&#x3D;insert, parameterTypes&#x3D;org.dromara.soul.examples.dubbo.api.entity.DubboTest, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:50.993  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397138167934976, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findAll, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboTestService, methodName&#x3D;findAll, parameterTypes&#x3D;null, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.012  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397138960658432, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findById, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboTestService, methodName&#x3D;findById, parameterTypes&#x3D;java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.060  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139031961600, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByIdsAndName, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByIdsAndName, parameterTypes&#x3D;java.util.List,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.079  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139103264768, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByArrayIdsAndName, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByArrayIdsAndName, parameterTypes&#x3D;[Ljava.lang.Integer;,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.100  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139182956544, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByStringArray, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByStringArray, parameterTypes&#x3D;[Ljava.lang.String;, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.126  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139258454016, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByListId, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByListId, parameterTypes&#x3D;java.util.List, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.153  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139346534400, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;batchSave, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;batchSave, parameterTypes&#x3D;java.util.List, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.169  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139413643264, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;batchSaveAndNameAndId, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;batchSaveAndNameAndId, parameterTypes&#x3D;java.util.List,java.lang.String,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.186  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139476557824, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;saveComplexBeanTest, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;saveComplexBeanTest, parameterTypes&#x3D;org.dromara.soul.examples.dubbo.api.entity.ComplexBeanTest, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.201  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139547860992, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;saveComplexBeanTestAndName, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;saveComplexBeanTestAndName, parameterTypes&#x3D;org.dromara.soul.examples.dubbo.api.entity.ComplexBeanTest,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br></pre></td></tr></table></figure>
使用curl 调用 soul-bootstrap 代理的接口：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl localhost:9195&#x2F;dubbo&#x2F;findAll </span><br><span class="line">&#x2F;&#x2F;返回了</span><br><span class="line">&#123;&quot;code&quot;:200,&quot;message&quot;:&quot;Access to success!&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;hello world Soul Alibaba Dubbo , findAll&quot;,&quot;id&quot;:&quot;654524173&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
表明我们通过soul成功调用了dubbo的接口。</li>
</ol>
<p>深入源码，在调用 “/dubbo/findAll” 这个路径时，dubbo plugin 执行了 doExecute 方法，然后从 ServerWebExchange 中分别获取到了<br>soulContext 和 metaData：<br><img src="https://img-blog.csdnimg.cn/202101170117309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210117011809380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在这两个对象中我们已经看到了即将调用到的DubboTestService和 对应的方法名 findAll。<br>在这里我们获取到了 genericService，并将封装好的方法名，参数通过 genericService 的 $invoke方法调用真实的dubbo服务endpoint，再将response 返回给soul-bootstrap这边。<br><img src="https://img-blog.csdnimg.cn/20210117012348487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：Dubbo插件非常强大，能够通过扫描zookeeper的方式将所有已注册的endpoint 并直接添加到规则中，这一点对于dubbo用户来说接入几乎是零成本的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（四）sign 插件</title>
    <url>/2021/01/19/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89sign-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一节中，我们尝试dubbo插件将http协议转换成dubbo协议，今天我们来看看 sign 插件是如何实现请求鉴权的。</p>
<a id="more"></a>
<h1 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h1><p>我们先试试没有添加sign插件时，是否能正常请求接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl localhost:9195&#x2F;dubbo&#x2F;findAll</span><br><span class="line">&#123;&quot;code&quot;:200,&quot;message&quot;:&quot;Access to success!&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;hello world Soul Alibaba Dubbo , findAll&quot;,&quot;id&quot;:&quot;-803129909&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>成功。</p>
<p>首先我们需要在插件管理中打开sign插件的开关。然后我们在认证管理中，新增一条 AK/SK 记录：<br><img src="https://img-blog.csdnimg.cn/20210119004613292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加完毕后，我们可以看到AppKey 和加密密钥已经为我们生成好了：<br><img src="https://img-blog.csdnimg.cn/20210119004712413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们再试试刚刚代理dubbo 服务中的 /dubbo/findAll 接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl localhost:9195&#x2F;dubbo&#x2F;findAll</span><br><span class="line">&#123;&quot;code&quot;:200,&quot;message&quot;:&quot;Access to success!&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;hello world Soul Alibaba Dubbo , findAll&quot;,&quot;id&quot;:&quot;-541002115&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>发现没有生效，原因是没有配置sign的选择器：<br><img src="https://img-blog.csdnimg.cn/20210119010246549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021011901033031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210119010334975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按照上图所示配置好sign选择器后再请求我们配置了鉴权校验的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl localhost:9195&#x2F;dubbo&#x2F;findAll</span><br><span class="line">&#123;&quot;code&quot;:401,&quot;message&quot;:&quot;sign parameters are incomplete!&quot;,&quot;data&quot;:null&#125;</span><br></pre></td></tr></table></figure>
<p>成了，提示我们签名参数不完整，下表展示了我们需要在headers中添加的header：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp</td>
<td>1571711067186</td>
<td>上述你进行签名的时候使用的时间值</td>
</tr>
<tr>
<td>appKey</td>
<td>1TEST123456781</td>
<td>AK值</td>
</tr>
<tr>
<td>sign</td>
<td>A90E66763793BDBC817CF3B52AAAC041</td>
<td>上述得到的签名值</td>
</tr>
<tr>
<td>version</td>
<td>1.0.0</td>
<td>固定默认值</td>
</tr>
<tr>
<td>签名插件会默认过滤5分钟之后的请求。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>现在直奔单元测试类，把现有的时间戳，appkey 和 sign 改写成自己的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SignService signService;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> ServerWebExchange exchange;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//这里改成自己的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String appKey = <span class="string">"E841FEDBF8EE4912878993EC84F70947"</span>;</span><br><span class="line">   <span class="comment">//这里改成自己的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String secretKey = <span class="string">"4FBB99E1B97B45D79D8F891D45DBB97E"</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> SoulContext passed;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;soul.sign.delay:5&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> delay;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.signService = <span class="keyword">new</span> DefaultSignService();</span><br><span class="line">       <span class="keyword">this</span>.exchange = MockServerWebExchange.from(MockServerHttpRequest.get(<span class="string">"localhost"</span>).build());</span><br><span class="line">       <span class="comment">//这里改成自己的，路径是默认签名的一部分</span></span><br><span class="line">       <span class="keyword">final</span> String path = <span class="string">"/dubbo/findAll"</span>;</span><br><span class="line">       PluginData signData = <span class="keyword">new</span> PluginData();</span><br><span class="line">       signData.setId(<span class="string">"1"</span>);</span><br><span class="line">       signData.setName(PluginEnum.SIGN.getName());</span><br><span class="line">       signData.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">       signData.setRole(<span class="number">1</span>);</span><br><span class="line">       BaseDataCache.getInstance().cachePluginData(signData);</span><br><span class="line">       </span><br><span class="line">       AppAuthData authData = <span class="keyword">new</span> AppAuthData();</span><br><span class="line">       authData.setAppKey(appKey);</span><br><span class="line">       authData.setAppSecret(secretKey);</span><br><span class="line">       authData.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">       AuthPathData authPathData = <span class="keyword">new</span> AuthPathData();</span><br><span class="line">       authPathData.setAppName(<span class="string">"test-api"</span>);</span><br><span class="line">       authPathData.setPath(path);</span><br><span class="line">       authPathData.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">       authData.setPathDataList(Lists.newArrayList(authPathData));</span><br><span class="line">       SignAuthDataCache.getInstance().cacheAuthData(authData);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">this</span>.passed = <span class="keyword">new</span> SoulContext();</span><br><span class="line">       <span class="keyword">this</span>.passed.setModule(<span class="string">"/dubbo"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setMethod(<span class="string">"/findAll"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setRpcType(<span class="string">"dubbo"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setHttpMethod(<span class="string">"GET"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setPath(path);</span><br><span class="line">       <span class="keyword">final</span> String timestamp = String.valueOf(System.currentTimeMillis());</span><br><span class="line">       <span class="keyword">this</span>.passed.setTimestamp(timestamp);</span><br><span class="line">       <span class="keyword">this</span>.passed.setSign(buildSign(secretKey, timestamp, <span class="keyword">this</span>.passed.getPath()));</span><br><span class="line">       <span class="comment">//在这里打断点，获取到 this.getpassed 中的sign</span></span><br><span class="line">       <span class="keyword">this</span>.passed.setAppKey(appKey);</span><br><span class="line">       <span class="keyword">this</span>.passed.setContextPath(<span class="string">"/"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setRealUrl(<span class="string">"/dubbo/findAll"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们在postman 请求的 headers 中添加签名相关的header并请求：<br><img src="https://img-blog.csdnimg.cn/20210119012826823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功通过了校验。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type Default sign service.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoyu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSignService</span> <span class="keyword">implements</span> <span class="title">SignService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以自定义sign过期时间，单位为分钟</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;soul.sign.delay:5&#125;"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> delay;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pair&lt;Boolean, String&gt; <span class="title">signVerify</span><span class="params">(<span class="keyword">final</span> ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        PluginData signData = BaseDataCache.getInstance().obtainPluginData(PluginEnum.SIGN.getName());</span><br><span class="line">        <span class="comment">//需要配置 sign 插件且 sign 插件是激活状态</span></span><br><span class="line">        <span class="keyword">if</span> (signData != <span class="keyword">null</span> &amp;&amp; signData.getEnabled()) &#123;</span><br><span class="line">            <span class="keyword">final</span> SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);</span><br><span class="line">            <span class="keyword">assert</span> soulContext != <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//执行verify方法校验签名</span></span><br><span class="line">            <span class="keyword">return</span> verify(soulContext, exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pair.of(Boolean.TRUE, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Pair&lt;Boolean, String&gt; <span class="title">verify</span><span class="params">(<span class="keyword">final</span> SoulContext soulContext, <span class="keyword">final</span> ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//任意为空，则失败</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(soulContext.getAppKey())</span><br><span class="line">                || StringUtils.isBlank(soulContext.getSign())</span><br><span class="line">                || StringUtils.isBlank(soulContext.getTimestamp())) &#123;</span><br><span class="line">            log.error(<span class="string">"sign parameters are incomplete,&#123;&#125;"</span>, soulContext);</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_PARAMS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前的时间戳</span></span><br><span class="line">        <span class="keyword">final</span> LocalDateTime start = DateUtils.formatLocalDateTimeFromTimestampBySystemTimezone(Long.parseLong(soulContext.getTimestamp()));</span><br><span class="line">        <span class="keyword">final</span> LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> between = DateUtils.acquireMinutesBetween(start, now);</span><br><span class="line">        <span class="comment">//跟delay做比对</span></span><br><span class="line">        <span class="keyword">if</span> (between &gt; delay) &#123;</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, String.format(SoulResultEnum.SING_TIME_IS_TIMEOUT.getMsg(), delay));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign(soulContext, exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * verify sign .</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> soulContext &#123;<span class="doctag">@linkplain</span> SoulContext&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result : True is pass, False is not pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Pair&lt;Boolean, String&gt; <span class="title">sign</span><span class="params">(<span class="keyword">final</span> SoulContext soulContext, <span class="keyword">final</span> ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AppAuthData appAuthData = SignAuthDataCache.getInstance().obtainAuthData(soulContext.getAppKey());</span><br><span class="line">        <span class="comment">//一系列判空逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(appAuthData) || !appAuthData.getEnabled()) &#123;</span><br><span class="line">            log.error(<span class="string">"sign APP_kEY does not exist or has been disabled,&#123;&#125;"</span>, soulContext.getAppKey());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_APP_KEY_IS_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;AuthPathData&gt; pathDataList = appAuthData.getPathDataList();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(pathDataList)) &#123;</span><br><span class="line">            log.error(<span class="string">"You have not configured the sign path:&#123;&#125;"</span>, soulContext.getAppKey());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_PATH_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">//查看path是否在配置列表中</span></span><br><span class="line">        <span class="keyword">boolean</span> match = pathDataList.stream().filter(AuthPathData::getEnabled)</span><br><span class="line">                .anyMatch(e -&gt; PathMatchUtils.match(e.getPath(), soulContext.getPath()));</span><br><span class="line">        <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">            log.error(<span class="string">"You have not configured the sign path:&#123;&#125;,&#123;&#125;"</span>, soulContext.getAppKey(), soulContext.getRealUrl());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_PATH_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        String sigKey = SignUtils.generateSign(appAuthData.getAppSecret(), buildParamsMap(soulContext));</span><br><span class="line">        <span class="keyword">boolean</span> result = Objects.equals(sigKey, soulContext.getSign());</span><br><span class="line">        <span class="comment">//校验sign是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            log.error(<span class="string">"the SignUtils generated signature value is:&#123;&#125;,the accepted value is:&#123;&#125;"</span>, sigKey, soulContext.getSign());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_VALUE_IS_ERROR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;AuthParamData&gt; paramDataList = appAuthData.getParamDataList();</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(paramDataList)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Pair.of(Boolean.TRUE, <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            paramDataList.stream().filter(p -&gt;</span><br><span class="line">                    (<span class="string">"/"</span> + p.getAppName()).equals(soulContext.getContextPath()))</span><br><span class="line">                    .map(AuthParamData::getAppParam)</span><br><span class="line">                    .filter(StringUtils::isNoneBlank).findFirst()</span><br><span class="line">                    .ifPresent(param -&gt; exchange.getRequest().mutate().headers(httpHeaders -&gt; httpHeaders.set(Constants.APP_PARAM, param)).build()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pair.of(Boolean.TRUE, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">buildParamsMap</span><span class="params">(<span class="keyword">final</span> SoulContext dto)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(<span class="number">3</span>);</span><br><span class="line">        map.put(Constants.TIMESTAMP, dto.getTimestamp());</span><br><span class="line">        map.put(Constants.PATH, dto.getPath());</span><br><span class="line">        map.put(Constants.VERSION, <span class="string">"1.0.0"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实签名插件的核心逻辑比较简单，就是实现了 sign 、 verify等方法，再实现 SignService 接口的 signVerify函数完成整个签名的流程。如果有需要我们可以加入自己的签名校验逻辑，比如用JWT之类的来实现，只需要实现 SignService 接口的 signVerify 即可。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（五）Spring Cloud 插件（一）</title>
    <url>/2021/01/19/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Spring-Cloud-%E6%8F%92%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇文章中我们学习了 sign 插件是如何实现请求鉴权的，今天我们来试试 Soul 的Spring Cloud 插件。</p>
<a id="more"></a>
<h2 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h2><p>先解除soul-bootstrap Spring Cloud 依赖部分的如下注释：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!--soul springCloud plugin start--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dromara<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>soul-spring-boot-starter-plugin-springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--soul springCloud plugin start end--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- springCloud if you config register center is nacos please dependency this--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- springCloud if you config register center is eureka please dependency end--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Cloud 插件支持 Nacos 或者 Eureka作为服务注册中的，这一次我们选择Eureka。</p>
<p>在 soul-bootstrap 的 application.yml 中添加Eureka 相关依赖：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在 soul-admin 中开启Spring Cloud 插件支持。<br><img src="https://img-blog.csdnimg.cn/20210119224248721.png" alt="在这里插入图片描述"><br>直接启动 soul-examples-springcloud 和 soul-examples-eureka，打开Eureka的页面可以看到已经把我们的应用注册好了。<br><img src="https://img-blog.csdnimg.cn/2021011922585019.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再回到 soul-admin，发现我们的 Spring Cloud 服务的相关 endpoints 已经加到了选择器和规则列表中：<br><img src="https://img-blog.csdnimg.cn/20210119230144991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们用 curl 来测试下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl &quot;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hello world spring cloud findById&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>成功返回数据。现在我们使用wrk执行一下压测，以下是不适用soul网关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ wrk -t8 -c200 -d30s --latency  &quot;http:&#x2F;&#x2F;localhost:8884&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">Running 30s test @ http:&#x2F;&#x2F;localhost:8884&#x2F;order&#x2F;findById?id&#x3D;1</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency     8.21ms    6.05ms 155.20ms   92.54%</span><br><span class="line">    Req&#x2F;Sec     2.95k   703.14    15.51k    79.58%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    7.27ms</span><br><span class="line">     75%    9.19ms</span><br><span class="line">     90%   11.65ms</span><br><span class="line">     99%   33.06ms</span><br><span class="line">  700305 requests in 30.07s, 119.00MB read</span><br><span class="line">Requests&#x2F;sec:  23285.91</span><br><span class="line">Transfer&#x2F;sec:      3.96MB</span><br></pre></td></tr></table></figure>
<p>使用soul网关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ wrk -t8 -c200 -d30s --latency  &quot;http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">Running 30s test @ http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency    47.59ms   37.60ms 294.45ms   80.29%</span><br><span class="line">    Req&#x2F;Sec   592.92    129.17     0.97k    70.40%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   36.84ms</span><br><span class="line">     75%   61.51ms</span><br><span class="line">     90%   99.43ms</span><br><span class="line">     99%  176.76ms</span><br><span class="line">  141697 requests in 30.10s, 28.13MB read</span><br><span class="line">Requests&#x2F;sec:   4707.18</span><br><span class="line">Transfer&#x2F;sec:      0.93MB</span><br></pre></td></tr></table></figure>
<p>可能跟笔者机器有关，网关在8个线程200个连接测试30秒的情况，延迟有比较明显的提升，初步怀疑受到了日志输出的影响，调整日志输出级别后再进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ wrk -t8 -c200 -d30s --latency  &quot;http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">Running 30s test @ http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">^C  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency    39.94ms   26.08ms 218.19ms   71.90%</span><br><span class="line">    Req&#x2F;Sec   657.54    122.81     0.91k    78.91%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   35.04ms</span><br><span class="line">     75%   53.40ms</span><br><span class="line">     90%   74.22ms</span><br><span class="line">     99%  122.25ms</span><br><span class="line">  33581 requests in 6.44s, 6.67MB read</span><br><span class="line">Requests&#x2F;sec:   5214.23</span><br><span class="line">Transfer&#x2F;sec:      1.04MB</span><br></pre></td></tr></table></figure>
<p>设置日志输出级别为error后性能损耗要小一些。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（六）使用websocket同步数据到网关</title>
    <url>/2021/01/21/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E4%BD%BF%E7%94%A8websocket%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>Soul 提供了多种数据同步的策略，默认且推荐的方式是使用 websocket。为了追求极致的响应速度，所有的配置没有选择存到redis，MySQL或是其他存储方式中，而是直接在HashMap中缓存，可以达到极低的延迟。</p>
<a id="more"></a>
<p>下图是三种策略下，Soul 网关与 soul-admin 数据同步的流程：<br><img src="https://img-blog.csdnimg.cn/20210121001006462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>借助websocket的特性，DataChangedEventDispatcher 得以主动向 Soul 网关推送数据变更。当 soul-admin 与 soul-bootstrap 首次建立连接时，会向soul-bootstrap 推送一次全量的配置数据，增量的数据也可以由 soul-admin 主动推送给 soul-bootstrap。</p>
<p>soul-admin 会根据配置加载以下的 bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The WebsocketListener(default strategy).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"soul.sync.websocket.enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(WebsocketSyncProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">WebsocketListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听数据变化的listener.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data changed listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(WebsocketDataChangedListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataChangedListener</span> <span class="title">websocketDataChangedListener</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebsocketDataChangedListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket服务端，负责websocket 数据的 OnOpen，OnMessage，OnClose，OnError等生命周期的处理和数据推送。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the websocket collector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(WebsocketCollector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">WebsocketCollector</span> <span class="title">websocketCollector</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebsocketCollector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server endpoint exporter server endpoint exporter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the server endpoint exporter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(ServerEndpointExporter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ServerEndpointExporter</span> <span class="title">serverEndpointExporter</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，WebsocketDataChangedListener 封装了对一系列数据的监听，以插件变更监听为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; pluginDataList, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先封装 websocket 数据，再使用 WebsocketCollector 来发送json序列化后的数据到 soul-bootstrap.</span></span><br><span class="line">    WebsocketData&lt;PluginData&gt; websocketData =</span><br><span class="line">            <span class="keyword">new</span> WebsocketData&lt;&gt;(ConfigGroupEnum.PLUGIN.name(), eventType.name(), pluginDataList);</span><br><span class="line">    WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type Websocket data changed listener.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoyu(Myth)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huangxiaofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketCollector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Session&gt; SESSION_SET = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SESSION_KEY = <span class="string">"sessionKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 略 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * On message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message the message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session the session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">final</span> String message, <span class="keyword">final</span> Session session)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 只有 message 的类型是 MYSELF时才处理</span></span><br><span class="line">        <span class="keyword">if</span> (message.equals(DataEventTypeEnum.MYSELF.name())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//将 websocket session 保存到 ThreadLocal 中。</span></span><br><span class="line">                ThreadLocalUtil.put(SESSION_KEY, session);</span><br><span class="line">                </span><br><span class="line">                SpringBeanUtils.getInstance().getBean(SyncDataService<span class="class">.<span class="keyword">class</span>).<span class="title">syncAll</span>(<span class="title">DataEventTypeEnum</span>.<span class="title">MYSELF</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalUtil.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message the message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type    the type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String message, <span class="keyword">final</span> DataEventTypeEnum type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(message)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DataEventTypeEnum.MYSELF == type) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        session.getBasicRemote().sendText(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"websocket send result is exception: "</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向所有存在的session 发送消息</span></span><br><span class="line">            <span class="keyword">for</span> (Session session : SESSION_SET) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"websocket send result is exception: "</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到当 DataEventTypeEnum 是 MYSELF 时，也就是客户端发来 MYSELF 消息时，服务端会把所有的配置数据同步给客户端，具体的代码实现在 WebsocketSyncDataConfiguration 这个类加载、创建 WebsocketSyncDataService bean 时，在 WebsocketSyncDataService 类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketSyncDataService</span> <span class="keyword">implements</span> <span class="title">SyncDataService</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;WebSocketClient&gt; clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor executor;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WebsocketSyncDataService</span><span class="params">(<span class="keyword">final</span> WebsocketConfig websocketConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                    <span class="keyword">final</span> PluginDataSubscriber pluginDataSubscriber,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                    <span class="keyword">final</span> List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                    <span class="keyword">final</span> List&lt;AuthDataSubscriber&gt; authDataSubscribers)</span> </span>&#123;</span><br><span class="line">	        String[] urls = StringUtils.split(websocketConfig.getUrls(), <span class="string">","</span>);</span><br><span class="line">	        executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(urls.length, SoulThreadFactory.create(<span class="string">"websocket-connect"</span>, <span class="keyword">true</span>));</span><br><span class="line">	        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	            	<span class="comment">//遍历所有url，将 SoulWebsocketClient 实例加到 clients中</span></span><br><span class="line">	                clients.add(<span class="keyword">new</span> SoulWebsocketClient(<span class="keyword">new</span> URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">	                log.error(<span class="string">"websocket url(&#123;&#125;) is error"</span>, url, e);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">        <span class="comment">/** 略 **/</span></span><br></pre></td></tr></table></figure>
<p>而在实例化 SoulWebsocketClient时，会调用如下的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="keyword">final</span> ServerHandshake serverHandshake)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!alreadySync) &#123;</span><br><span class="line">         send(DataEventTypeEnum.MYSELF.name());</span><br><span class="line">         alreadySync = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>client会在 websocket open 的时候 发送 MYSELF 消息到服务端，验证了上面我们的想法。其他类型的 DataEventTypeEnum 发送则是通过 onMessage 处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>soul 巧妙得运用了 websocket 进行数据同步，将数据直接放到JVM的方法也体现了对性能的极致追求。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（七）使用zookeeper同步数据到网关</title>
    <url>/2021/01/22/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E4%BD%BF%E7%94%A8zookeeper%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>与 websocket 数据同步方式类似，采用 zookeeper 的同步也很简单， 由于 zookeeper 的 watch 机制，sou-bootstrap 会监听配置的node，soul-admin 在启动的时候，也会跟websocker一样将数据全量写入 zookeeper。数据发生变更时，会对zookeeper 的节点做增量更新 ，并更新本地缓存。</p>
<a id="more"></a>
<h2 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h2><p>首先启动zookeeper，笔者使用 docker 启动。</p>
<p>推荐使用 ZooInspector 来直观地看到 zookeeper 中节点的数据。<br>下载地址：<br><a href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip" target="_blank" rel="noopener">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</a><br>使用方法：<br>在build 文件夹下执行 java -jar zookeeper-dev-ZooInspector.jar</p>
<p>下面我们来修改相关的配置使用 zookeeper来同步数据。先改 soul-bootstrap的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">soul :</span></span><br><span class="line">    <span class="attr">file:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">corss:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">dubbo :</span></span><br><span class="line">      <span class="attr">parameter:</span> <span class="string">multi</span></span><br><span class="line">    <span class="attr">sync:</span></span><br><span class="line"><span class="comment">#        websocket :</span></span><br><span class="line"><span class="comment">#             urls: ws://localhost:9095/websocket</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">zookeeper:</span></span><br><span class="line">             <span class="attr">url:</span> <span class="string">localhost:2181</span></span><br><span class="line">             <span class="attr">sessionTimeout:</span> <span class="number">5000</span></span><br><span class="line">             <span class="attr">connectionTimeout:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<p>再改soul-admin 的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">soul:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">    <span class="attr">dialect:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">init_script:</span> <span class="string">"META-INF/schema.sql"</span></span><br><span class="line">    <span class="attr">init_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sync:</span></span><br><span class="line"><span class="comment">#    websocket:</span></span><br><span class="line"><span class="comment">#      enabled: true</span></span><br><span class="line">      <span class="attr">zookeeper:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">localhost:2181</span></span><br><span class="line">          <span class="attr">sessionTimeout:</span> <span class="number">5000</span></span><br><span class="line">          <span class="attr">connectionTimeout:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<p>注释掉websocket 下的配置并解除注释 zookeeper 相关配置。<br>启动 soul-bootstrap 和 soul-admin<br>可以看到 数据 已经写入了 zookeeper<br><img src="https://img-blog.csdnimg.cn/2021012200570892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>尝试修改数据：<br><img src="https://img-blog.csdnimg.cn/20210122005942345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现一个奇怪的bug，跟到源码发现了问题，喜提issue：<br><img src="https://img-blog.csdnimg.cn/20210122010015709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210122011324157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>重新添加 selector，再点击同步，成功同步到了zookeeper。</p>
<h2 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type Zookeeper listener.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"soul.sync.zookeeper"</span>, name = <span class="string">"url"</span>)</span><br><span class="line">    <span class="meta">@Import</span>(ZookeeperConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">ZookeeperListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里如果开启了zookeeper相关配置，会加载 ZookeeperDataChangedListener bean。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> zkClient the zk client</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the data changed listener</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span>(ZookeeperDataChangedListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">DataChangedListener</span> <span class="title">zookeeperDataChangedListener</span>(<span class="title">final</span> <span class="title">ZkClient</span> <span class="title">zkClient</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperDataChangedListener(zkClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 负责同步初始化数据。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> zkClient        the zk client</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> syncDataService the sync data service</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the zookeeper data init</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span>(ZookeeperDataInit<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">ZookeeperDataInit</span> <span class="title">zookeeperDataInit</span>(<span class="title">final</span> <span class="title">ZkClient</span> <span class="title">zkClient</span>, <span class="title">final</span> <span class="title">SyncDataService</span> <span class="title">syncDataService</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperDataInit(zkClient, syncDataService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是 ZookeeperDataChangedListener中对应事件监听处理的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperDataChangedListener</span> <span class="keyword">implements</span> <span class="title">DataChangedListener</span> </span>&#123;</span><br><span class="line">	<span class="comment">//zookeeper 客户端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperDataChangedListener</span><span class="params">(<span class="keyword">final</span> ZkClient zkClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = zkClient;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//监听到 应用鉴权变更</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppAuthChanged</span><span class="params">(<span class="keyword">final</span> List&lt;AppAuthData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AppAuthData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String appAuthPath = ZkPathConstants.buildAppAuthPath(data.getAppKey());</span><br><span class="line">            <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(appAuthPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create or update</span></span><br><span class="line">            upsertZkNode(appAuthPath, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听到 元数据变更</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMetaDataChanged</span><span class="params">(<span class="keyword">final</span> List&lt;MetaData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MetaData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String metaDataPath = ZkPathConstants.buildMetaDataPath(URLEncoder.encode(data.getPath(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(metaDataPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create or update</span></span><br><span class="line">            upsertZkNode(metaDataPath, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//监听到 插件变更</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PluginData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String pluginPath = ZkPathConstants.buildPluginPath(data.getName());</span><br><span class="line">            <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">            	<span class="comment">//先删除再更新</span></span><br><span class="line">                deleteZkPathRecursive(pluginPath);</span><br><span class="line">                <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getName());</span><br><span class="line">                deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">                <span class="keyword">final</span> String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getName());</span><br><span class="line">                deleteZkPathRecursive(ruleParentPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//create or update</span></span><br><span class="line">            upsertZkNode(pluginPath, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//监听到 选择器变更</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSelectorChanged</span><span class="params">(<span class="keyword">final</span> List&lt;SelectorData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eventType == DataEventTypeEnum.REFRESH) &#123;</span><br><span class="line">            <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(changed.get(<span class="number">0</span>).getPluginName());</span><br><span class="line">            deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SelectorData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String selectorRealPath = ZkPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());</span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(selectorRealPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getPluginName());</span><br><span class="line">            createZkNode(selectorParentPath);</span><br><span class="line">            <span class="comment">//create or update</span></span><br><span class="line">            upsertZkNode(selectorRealPath, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//监听到 规则变更</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRuleChanged</span><span class="params">(<span class="keyword">final</span> List&lt;RuleData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eventType == DataEventTypeEnum.REFRESH) &#123;</span><br><span class="line">            <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildRuleParentPath(changed.get(<span class="number">0</span>).getPluginName());</span><br><span class="line">            deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RuleData data : changed) &#123;</span><br><span class="line">            <span class="keyword">final</span> String ruleRealPath = ZkPathConstants.buildRulePath(data.getPluginName(), data.getSelectorId(), data.getId());</span><br><span class="line">            <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">                deleteZkPath(ruleRealPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getPluginName());</span><br><span class="line">            createZkNode(ruleParentPath);</span><br><span class="line">            <span class="comment">//create or update</span></span><br><span class="line">            upsertZkNode(ruleRealPath, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createZkNode</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(path)) &#123;</span><br><span class="line">            zkClient.createPersistent(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有则更新、无则创建节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path node path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data node data </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upsertZkNode</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(path)) &#123;</span><br><span class="line">            zkClient.createPersistent(path, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        zkClient.writeData(path, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除路径</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteZkPath</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(path)) &#123;</span><br><span class="line">            zkClient.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归删除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteZkPathRecursive</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(path)) &#123;</span><br><span class="line">            zkClient.deleteRecursive(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>zookeeper 的同步方式相对与websocket 性能上差距应该不大，实现原理也类似，比较麻烦的是需要维护 zookeeper，而使用 websocket 则没有这样的问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（八）使用 http 长轮询同步数据到网关</title>
    <url>/2021/01/23/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%E4%BD%BF%E7%94%A8-http-%E9%95%BF%E8%BD%AE%E8%AF%A2%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>今天我们使用 http长轮询来同步数据到soul-bootstrap，相比websocket方式更为轻量，但同时时效性会略为降低。首先我们来看看什么是http长轮询。</p>
<a id="more"></a>
<p>短连接：client每向server发起一次http请求，就建立一个tpc连接，任务结束则中断。</p>
<p>在http长轮询机制中，client一样向server请求数据。然而，如果server没有可以立即返回给client的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时：小于ajax的超时时间），此时client进入之pending状态，server将数据准备好或超时后返回给client。</p>
<p>整个流程如图所示:<br><img src="https://img-blog.csdnimg.cn/20210123064940962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>网关配置（记得重启）</p>
<p>首先在 pom.xml 文件中 引入以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--soul data sync start use http--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.dromara&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;soul-spring-boot-starter-sync-data-http&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;last.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在 springboot的 yml 文件中进行如下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soul :</span><br><span class="line">   sync:</span><br><span class="line">       http:</span><br><span class="line">            url: http:&#x2F;&#x2F;localhost:9095</span><br></pre></td></tr></table></figure>
<h2 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据配置项加载HttpLongPollingDataChangedListener这个bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"soul.sync.http.enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpSyncProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">HttpLongPollingListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HttpLongPollingDataChangedListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">HttpLongPollingDataChangedListener</span> <span class="title">httpLongPollingDataChangedListener</span>(<span class="title">final</span> <span class="title">HttpSyncProperties</span> <span class="title">httpSyncProperties</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpLongPollingDataChangedListener(httpSyncProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用 ArrayBlockingQueue 存放客户端，并创建一个单线程的 ScheduledThreadPoolExecutor 来实现周期性任务的调度</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> httpSyncProperties the HttpSyncProperties</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HttpLongPollingDataChangedListener</span><span class="params">(<span class="keyword">final</span> HttpSyncProperties httpSyncProperties)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.clients = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line">     <span class="keyword">this</span>.scheduler = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">             SoulThreadFactory.create(<span class="string">"long-polling"</span>, <span class="keyword">true</span>));</span><br><span class="line">     <span class="keyword">this</span>.httpSyncProperties = httpSyncProperties;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>HttpLongPollingDataChangedListener 中比较精髓的函数是 checkCacheDelayAndUpdate:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查客户端是否需要更新缓存</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> serverCache the admin local cache</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clientMd5 the client md5 value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clientModifyTime the client last modify time</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true: the client needs to be updated, false: not need.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkCacheDelayAndUpdate</span><span class="params">(<span class="keyword">final</span> ConfigDataCache serverCache, <span class="keyword">final</span> String clientMd5, <span class="keyword">final</span> <span class="keyword">long</span> clientModifyTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果MD5 值相等,则不用更新</span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.equals(clientMd5, serverCache.getMd5())) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果MD5 值不相等,则比较 lastModifyTime</span></span><br><span class="line">       <span class="keyword">long</span> lastModifyTime = serverCache.getLastModifyTime();</span><br><span class="line">       <span class="keyword">if</span> (lastModifyTime &gt;= clientModifyTime) &#123;</span><br><span class="line">           <span class="comment">// the client's config is out of date.</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// the lastModifyTime before client, then the local cache needs to be updated.</span></span><br><span class="line">       <span class="comment">// Considering the concurrency problem, admin must lock,</span></span><br><span class="line">       <span class="comment">// otherwise it may cause the request from soul-web to update the cache concurrently, causing excessive db pressure</span></span><br><span class="line">       <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       	<span class="comment">//尝试去获取锁, 超过5秒后放弃</span></span><br><span class="line">           locked = LOCK.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ConfigDataCache latest = CACHE.get(serverCache.getGroup());</span><br><span class="line">               <span class="keyword">if</span> (latest != serverCache) &#123;</span><br><span class="line">                   <span class="comment">// the cache of admin was updated. if the md5 value is the same, there's no need to update.</span></span><br><span class="line">                   <span class="comment">// 如果 admin 的缓存更新了 但 MD5 相等, 则不需要更新</span></span><br><span class="line">                   <span class="keyword">return</span> !StringUtils.equals(clientMd5, latest.getMd5());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 从数据库中读取数据并加入缓存</span></span><br><span class="line">               <span class="keyword">this</span>.refreshLocalCache();</span><br><span class="line">               latest = CACHE.get(serverCache.getGroup());</span><br><span class="line">               <span class="keyword">return</span> !StringUtils.equals(clientMd5, latest.getMd5());</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               LOCK.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// not locked, the client need to be updated.</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实 checkCacheDelayAndUpdate 跟最近做的 安卓更新检测接口很像, 巧妙地通过 时间 和 数据MD5 这两个因子对缓存做比较, 同时考虑到了并发场景, 添加了一个锁保证更新的原子性.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（九）使用 Nacos 同步数据到网关</title>
    <url>/2021/01/24/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BD%BF%E7%94%A8-Nacos-%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>Nacos 是一款发现、配置和微服务管理工具。它提供了一组简单易用的特性集，可以快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<a id="more"></a>
<p>安装启动好 Nacos 后，修改对应的 soul-admin 和 soul-bootstrap 中的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">soul:</span></span><br><span class="line">    <span class="attr">file:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">corss:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">dubbo :</span></span><br><span class="line">      <span class="attr">parameter:</span> <span class="string">multi</span></span><br><span class="line">    <span class="attr">sync:</span></span><br><span class="line"><span class="comment">#        websocket :</span></span><br><span class="line"><span class="comment">#             urls: ws://localhost:9095/websocket</span></span><br><span class="line">      <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">1c10d748-af86-43b9-8265-75f487d20c6c</span></span><br></pre></td></tr></table></figure>
<p>在 soul-bootstrap 的 pom.xml 中加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dromara<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>soul-spring-boot-starter-sync-data-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动 soul-admin 和 soul-bootstrap，发现 soul-bootstrap 无法启动，原因是在 NacosCacheHandler 类中，以下代码处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateMetaDataMap</span><span class="params">(<span class="keyword">final</span> String configInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//这里会抛出 NullPointerException ，因为暂时没有实现 Nacos 的数据初始化。</span></span><br><span class="line">        List&lt;MetaData&gt; metaDataList = <span class="keyword">new</span> ArrayList&lt;&gt;(GsonUtils.getInstance().toObjectMap(configInfo, MetaData<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">        metaDataList.forEach(metaData -&gt; metaDataSubscribers.forEach(subscriber -&gt; &#123;</span><br><span class="line">            subscriber.unSubscribe(metaData);</span><br><span class="line">            subscriber.onSubscribe(metaData);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">        log.error(<span class="string">"sync meta data have error:"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能在 Nacos 后台手动添加初始化数据，需要分别添加 元数据 和 认证的数据。详细的解决办法可以参考 <a href="https://www.jianshu.com/p/8294289145a7" target="_blank" rel="noopener">soul 网关入门篇（七）：数据同步方式- nacos 配置</a></p>
<p><code>2021-01-24 02:15:31.175  INFO 90111 --- [           main] d.s.s.s.s.d.n.NacosSyncDataConfiguration : you use nacos sync soul data......</code><br>看到这个代表已经成功使用 Nacos 同步数据了。</p>
<p>看一下 Nacos 的管理端情况，发现并没有数据，但是在 NacosDataChangedListener 打断点后点击同步数据的话，是能进到 对应的函数的：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4914a9d648a44b5bb6437f6ab62935b7~tplv-k3u1fbpfcp-watermark.image" alt=""><br>由于缺乏对 Nacos 的认知，我决定暂时蒙在鼓里。</p>
<p>Nacos 同步配置信息的逻辑非常简单，就是运用了 Nacos 中的 ConfigService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从Nacos配置服务获取配置</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getConfig</span><span class="params">(<span class="keyword">final</span> String dataId)</span> </span>&#123;</span><br><span class="line">    String config = configService.getConfig(dataId, GROUP, <span class="number">6000</span>);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.hasLength(config) ? config : EMPTY_CONFIG_DEFAULT_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布数据到Nacos配置服务</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishConfig</span><span class="params">(<span class="keyword">final</span> String dataId, <span class="keyword">final</span> Object data)</span> </span>&#123;</span><br><span class="line">    configService.publishConfig(dataId, GROUP, GsonUtils.getInstance().toJson(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Nacos 管理端添加对应的 namespace，对应soul-admin 和 soul-bootstrap 配置中的 namespace:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892574b601064cb6a4191da38bb5c578~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>再次查看配置管理，发现已经有了对应的配置数据json了。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd1430118c83448b9f766adbd6f3fd83~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nacos 有个独立的配置管理服务 ConfigService，如果要了解为什么在 Nacos 后台中看不到任何数据和节点，还需要深入了解 Nacos 配置服务的实现原理才行。用 Nacos 做数据同步跟Zookeeper 是同样的问题，需要维护额外的中间件造成维护成本的提升。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（十）使用集群模式部署soul-bootstrap</title>
    <url>/2021/01/26/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2soul-bootstrap/</url>
    <content><![CDATA[<p>分析了多种数据同步方式后，我们来试试 Soul 网关的<strong>集群模式</strong>。</p>
<a id="more"></a>

<p>首先我们使用 mvn clean intall &amp;&amp; mvn clean package 来打出jar包，进入 soul-bootstrap/target，使用以下命令才启动多个 soul-bootstrap 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar soul-bootstrap.jar --server.port&#x3D;8095</span><br><span class="line">java -jar soul-bootstrap.jar --server.port&#x3D;8096</span><br><span class="line">java -jar soul-bootstrap.jar --server.port&#x3D;8097</span><br></pre></td></tr></table></figure>
<p>启动三个服务后，我们需要用 nginx 做下负载均衡。</p>
<p>使用 vim 编写配置文件（其中 soul.hazyrain.com 可以换成你喜欢的域名，在 <strong>hosts</strong> 文件上做好配置即可）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置upstream，注意这个后面的 bootstrap 是 alias，把他配置到location 那里</span><br><span class="line">upstream bootstrap &#123;</span><br><span class="line">    server localhost:8095 fail_timeout&#x3D;3s max_fails&#x3D;2;</span><br><span class="line">    server localhost:8096 fail_timeout&#x3D;3s max_fails&#x3D;2;</span><br><span class="line">    server localhost:8097 fail_timeout&#x3D;3s max_fails&#x3D;2;</span><br><span class="line">    #添加 ip hash，能将来自同一 IP 的客户端请求派发给同一个服务实例</span><br><span class="line">    ip_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  soul.hazyrain.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>nginx -s reload</code> ，更新配置。</p>
<p>尝试访问 soul.hazyrain.com：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d6bc1b86984deab7f50c0058435738~tplv-k3u1fbpfcp-watermark.image" alt=""><br>OK，我们已经成功使用nginx 代理了 三个节点的 soul-bootstrap 集群。</p>
<p>现在我们来启动一个简单的 flask 应用，并在soul-admin 中配置对应规则：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b61479b498b42f4bcc817bdda95bf97~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>调用 soul-admin 注册 http 服务的接口注册服务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#POST请求：'http://localhost:9095/soul-client/springmvc-register'</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"appName"</span>: <span class="string">"fake-api"</span>,</span><br><span class="line">    <span class="string">"context"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"fake"</span>,</span><br><span class="line">    <span class="string">"rpcType"</span>: <span class="string">"http"</span>,</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"soul.hazyrain.com"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="string">"ruleName"</span>: <span class="string">"fake"</span>,</span><br><span class="line">    <span class="string">"enabled"</span>: <span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用 我们的nginx 代理集群的 endpoint：<code>http://soul.hazyrain.com/fake/foo/bar</code><br>成功返回数据：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/474e7e9d71504598aef1de76140a4842~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>使用 postman 的 runner 做下测试，执行500次调用，查看调用结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"id"</span>: <span class="string">"789bccc1-f41c-45ee-8033-aff647a1fab0"</span>,</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"soul"</span>,</span><br><span class="line">	<span class="attr">"timestamp"</span>: <span class="string">"2021-01-25T15:04:31.400Z"</span>,</span><br><span class="line">	<span class="attr">"collection_id"</span>: <span class="string">"be2b94d5-ff96-484f-b7e0-23bda6d4d908"</span>,</span><br><span class="line">	<span class="attr">"folder_id"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"environment_id"</span>: <span class="string">"0"</span>,</span><br><span class="line">	<span class="attr">"totalPass"</span>: <span class="number">1000</span>,</span><br><span class="line">	<span class="attr">"totalFail"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"results"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"id"</span>: <span class="string">"266f5d02-bfbe-4a93-8679-7267c8d75cd8"</span>,</span><br><span class="line">			<span class="attr">"name"</span>: <span class="string">"proxy test"</span>,</span><br><span class="line">			<span class="attr">"time"</span>: <span class="number">2</span>,</span><br><span class="line">			<span class="attr">"responseCode"</span>: &#123;</span><br><span class="line">				<span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"OK"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"tests"</span>: &#123;</span><br><span class="line">				<span class="attr">"Status code is 200"</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="attr">"Body matches string"</span>: <span class="literal">true</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"testPassFailCounts"</span>: &#123;</span><br><span class="line">				<span class="attr">"Status code is 200"</span>: &#123;</span><br><span class="line">					<span class="attr">"pass"</span>: <span class="number">500</span>,</span><br><span class="line">					<span class="attr">"fail"</span>: <span class="number">0</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">"Body matches string"</span>: &#123;</span><br><span class="line">					<span class="attr">"pass"</span>: <span class="number">500</span>,</span><br><span class="line">					<span class="attr">"fail"</span>: <span class="number">0</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"times"</span>: [],<span class="comment">//略</span></span><br><span class="line">			<span class="attr">"allTests"</span>: [] <span class="comment">//略</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">"count"</span>: <span class="number">500</span>,</span><br><span class="line">	<span class="attr">"totalTime"</span>: <span class="number">1675</span>,</span><br><span class="line">	<span class="attr">"collection"</span>: &#123;</span><br><span class="line">		<span class="attr">"requests"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"id"</span>: <span class="string">"266f5d02-bfbe-4a93-8679-7267c8d75cd8"</span>,</span><br><span class="line">				<span class="attr">"method"</span>: <span class="string">"GET"</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 count 和 totalTime 可以计算出，平均耗时为 3.35 毫秒，相当可观的数字。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Soul 网关能够支撑多个网关节点做负载均衡，配置也可通过soul-admin 同步到所有节点上。同时 websocket 断开链接后，soul-bootstrap 也有重连的机制，相当可靠。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（十一）ratelimiter 插件（一）</title>
    <url>/2021/01/27/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89ratelimiter-%E6%8F%92%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>Soul 网关提供了限流插件，方便用户控制指定时间段内经过网关的请求数量。</p>
<a id="more"></a>
<h2 id="什么是“限流”？"><a href="#什么是“限流”？" class="headerlink" title="什么是“限流”？"></a>什么是“限流”？</h2><p>火锅店一般都有最大的容客量，大桌小桌的席位数是固定的。在就餐高峰期时，大量的食客会蜂拥而至，一般火锅店的员工是根据座位数分配的，如果不限制进入火锅店的人流，员工会忙不过来，食客的体验也会变差。在这里限制座位数就是一种限流的手段。而取到号牌并被叫到号的顾客才能入座就餐，这跟令牌桶</p>
<p>后端架构中的限流一般分为两种，对外主要针对 DDOS攻击以及爬虫防范，对内主要控制热点公共服务调用的均匀分配。</p>
<h2 id="Soul-是如何做限流的？"><a href="#Soul-是如何做限流的？" class="headerlink" title="Soul 是如何做限流的？"></a>Soul 是如何做限流的？</h2><p>首先我们来看看 soul-plugin-ratelimiter 的文件目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── org</span><br><span class="line">    │   │       └── dromara</span><br><span class="line">    │   │           └── soul</span><br><span class="line">    │   │               └── plugin</span><br><span class="line">    │   │                   └── ratelimiter</span><br><span class="line">    │   │                       ├── RateLimiterPlugin.java AbstractSoulPlugin 实现类，核心函数是 doExecute，</span><br><span class="line">    │   │                       ├── config</span><br><span class="line">    │   │                       │   └── RateLimiterConfig.java ratelimiter 相关配置项</span><br><span class="line">    │   │                       ├── executor</span><br><span class="line">    │   │                       │   └── RedisRateLimiter.java 基于 redis 的令牌桶算法实现，核心函数是 isAllowed</span><br><span class="line">    │   │                       ├── handler</span><br><span class="line">    │   │                       │   └── RateLimiterPluginDataHandler.java 从插件配置读取数据的handler</span><br><span class="line">    │   │                       └── response</span><br><span class="line">    │   │                           └── RateLimiterResponse.java ratelimiter response 类</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       └── META-INF</span><br><span class="line">    │           └── scripts</span><br><span class="line">    │               ├── concurrent_request_rate_limiter.lua 并发 ratelimiter lua脚本</span><br><span class="line">    │               └── request_rate_limiter.lua ratelimiter lua脚本</span><br><span class="line">    └── test</span><br></pre></td></tr></table></figure>
<p>首先我们需要启动 redis-server</p>
<p>然后在 admin 中配置 ratelimiter 插件，首先在插件管理中开启 ratelimiter，再配置 ratelimiter 的 selecter 和 rule：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d322f3fc554e498f87aa3851e65c0824~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>配置完成后使用postman模拟不间断的 200 次请求：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b717650ad5e14096bd37db58b77b9356~tplv-k3u1fbpfcp-watermark.image" alt=""><br>在执行完 10 次后的 第11次，ratelimiter 阻断了我们的请求，因为令牌桶中的令牌已经被消耗光了（capacity 为 10），而填充速率（rate）为 5，意味着用户每秒最多请求 5次 后就被限流。</p>
<p>下图是令牌桶算法的分配流程，其实跟火锅店分配排队号牌是差不多的原理：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08542f0b3bce4f32b2608d2a7f021d3b~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ratelimiter 可以帮助我们在网关层过滤掉不需要或者异常的请求而避免消耗后端服务的资源，这也是我认为网关在软件架构中的重要职能之一，Soul 使用 redis 做令牌桶算法，明天的计划是深入剖析 通过 lua 脚本实现令牌桶算法的原理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（十二）ratelimiter 插件（二）</title>
    <url>/2021/01/27/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89ratelimiter-%E6%8F%92%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在上一篇我们熟悉了限流已经 ratelimiter 插件的实现原理，今天我们从源码入手详细地理一下整个流程。</p>
<a id="more"></a>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>RedisRateLimiter类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisRateLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里会调用 redisScript函数，读取并设置 this.script</span></span><br><span class="line">    <span class="keyword">this</span>.script = redisScript();</span><br><span class="line">    initialized.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id            规则ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> replenishRate 刷新率，就是每次填充进来的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> burstCapacity 令牌桶的最大容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Response&gt;&#125; to indicate when request processing is complete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;RateLimiterResponse&gt; <span class="title">isAllowed</span><span class="params">(<span class="keyword">final</span> String id, <span class="keyword">final</span> <span class="keyword">double</span> replenishRate, <span class="keyword">final</span> <span class="keyword">double</span> burstCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果没有初始化完成，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.initialized.get()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"RedisRateLimiter is not initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; keys = getKeys(id);</span><br><span class="line">    <span class="comment">//构造 redis 脚本参数，等会我们去lua脚本看看</span></span><br><span class="line">    List&lt;String&gt; scriptArgs = Arrays.asList(replenishRate + <span class="string">""</span>, burstCapacity + <span class="string">""</span>, Instant.now().getEpochSecond() + <span class="string">""</span>, <span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">//通过 ReactiveRedisTemplate 来执行在构造函数中加载的脚本</span></span><br><span class="line">    Flux&lt;List&lt;Long&gt;&gt; resultFlux = Singleton.INST.get(ReactiveRedisTemplate<span class="class">.<span class="keyword">class</span>).<span class="title">execute</span>(<span class="title">this</span>.<span class="title">script</span>, <span class="title">keys</span>, <span class="title">scriptArgs</span>)</span>;</span><br><span class="line">    <span class="comment">//当有异常发生时接收异常信息，输出和流中数据的类型相同的值，使用这个返回值替代异常的数据值返回给Subscriber</span></span><br><span class="line">    <span class="keyword">return</span> resultFlux.onErrorResume(throwable -&gt; Flux.just(Arrays.asList(<span class="number">1L</span>, -<span class="number">1L</span>))) </span><br><span class="line">    		<span class="comment">//对返回的 List&lt;Long&gt; 做 reduce 操作</span></span><br><span class="line">            .reduce(<span class="keyword">new</span> ArrayList&lt;Long&gt;(), (longs, l) -&gt; &#123;</span><br><span class="line">                longs.addAll(l);</span><br><span class="line">                <span class="keyword">return</span> longs;</span><br><span class="line">            &#125;).map(results -&gt; &#123; <span class="comment">//针对流中的每一个元素，执行对应操作</span></span><br><span class="line">                <span class="keyword">boolean</span> allowed = results.get(<span class="number">0</span>) == <span class="number">1L</span>; <span class="comment">//如果 第一个结果是 1L，则允许请求通过</span></span><br><span class="line">                Long tokensLeft = results.get(<span class="number">1</span>); <span class="comment">//获取桶中剩余的 token 数量</span></span><br><span class="line">                RateLimiterResponse rateLimiterResponse = <span class="keyword">new</span> RateLimiterResponse(allowed, tokensLeft);</span><br><span class="line">                log.info(<span class="string">"RateLimiter response:&#123;&#125;"</span>, rateLimiterResponse.toString());</span><br><span class="line">                <span class="keyword">return</span> rateLimiterResponse;</span><br><span class="line">            &#125;).doOnError(throwable -&gt; log.error(<span class="string">"Error determining if user allowed from redis:&#123;&#125;"</span>, throwable.getMessage()));<span class="comment">//在发生异常时打印日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看看 Lua 脚本中的内容：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--接收 tokens_key 和 timestamp_key</span></span><br><span class="line"><span class="keyword">local</span> tokens_key = KEYS[<span class="number">1</span>] </span><br><span class="line"><span class="keyword">local</span> timestamp_key = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="comment">--将 rate, capacity, 当前秒级时间戳, 和 requested 参数传入，从Java代码中看到是 "1"</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> requested = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"><span class="comment">-- 填充时间，计算出填充需要的时间，在上一节中我们的 capacity 设置为10，rate 为5 则填充时间为 2</span></span><br><span class="line"><span class="keyword">local</span> fill_time = capacity/rate</span><br><span class="line"><span class="comment">-- 对填充时间向上取整，获取 key 的过期时间</span></span><br><span class="line"><span class="keyword">local</span> ttl = <span class="built_in">math</span>.<span class="built_in">floor</span>(fill_time*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取剩余的 token 数量</span></span><br><span class="line"><span class="keyword">local</span> last_tokens = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, tokens_key))</span><br><span class="line"><span class="keyword">if</span> last_tokens == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 如果不存在这个 key 则初始化令牌桶</span></span><br><span class="line">  last_tokens = capacity</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取最近更新的时间戳</span></span><br><span class="line"><span class="keyword">local</span> last_refreshed = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, timestamp_key))</span><br><span class="line"><span class="keyword">if</span> last_refreshed == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 如果不存在这个key，则设置value 为 0</span></span><br><span class="line">  last_refreshed = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 计算当前时间与上次更新时间的 时间差（秒）</span></span><br><span class="line"><span class="keyword">local</span> delta = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, now-last_refreshed)</span><br><span class="line"><span class="comment">-- 计算已经填充到桶中的令牌数，取桶容量 和 剩余令牌数加上时间差乘以填充速率 中**最小**的那个值</span></span><br><span class="line"><span class="keyword">local</span> filled_tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, last_tokens+(delta*rate))</span><br><span class="line"><span class="comment">-- 计算是否允许请求和核心步骤：判断剩余令牌数是否大于等于1</span></span><br><span class="line"><span class="keyword">local</span> allowed = filled_tokens &gt;= requested</span><br><span class="line"><span class="comment">-- 用一个变量存储更新后的 token数</span></span><br><span class="line"><span class="keyword">local</span> new_tokens = filled_tokens</span><br><span class="line"><span class="keyword">local</span> allowed_num = <span class="number">0</span></span><br><span class="line"><span class="comment">-- 如果允许通过，则将减去 1 的令牌数更新到 tokens_key 中</span></span><br><span class="line"><span class="keyword">if</span> allowed <span class="keyword">then</span></span><br><span class="line">  new_tokens = filled_tokens - requested</span><br><span class="line">  allowed_num = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用 setex 来设置 key 过期时间 和 value</span></span><br><span class="line">redis.call(<span class="string">"setex"</span>, tokens_key, ttl, new_tokens)</span><br><span class="line">redis.call(<span class="string">"setex"</span>, timestamp_key, ttl, now)</span><br><span class="line"><span class="comment">-- 返回表示状态的 allowed_num 和 剩余 token数</span></span><br><span class="line"><span class="keyword">return</span> &#123; allowed_num, new_tokens &#125;</span><br></pre></td></tr></table></figure>
<p>下面是整个 限流计算的流程图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bd48d035ec44e6882df34e20b5211a~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ratelimiter 插件巧妙地运用 Lua 脚本执行 redis 来实现，保证了操作的原子性，也借助 redis 的高速率以几乎无损的延迟做到了限流的功能。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（十三）divide 插件（三)</title>
    <url>/2021/01/30/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89divide-%E6%8F%92%E4%BB%B6%EF%BC%88%E4%B8%89/</url>
    <content><![CDATA[<p>今天我们继续看 divide 下的随机负载均衡策略，手先看下 这个 Random 类在 MomoSec 插件中被规则检测出了：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfaec6cf8d2144b6b70f533412e3d9e6~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>其中的描述提到：java.util.Random依赖一个可被预测的伪随机数生成器，因为</p>
<ol>
<li>java.util.Random类中实现的随机算法是伪随机，也就是有规则的随机，所谓有规则的就是在给定种(seed)的区间内随机生成数字；</li>
<li>相同种子数的Random对象，相同次数生成的随机数字是完全相同的；</li>
<li>Random类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率均等；</li>
</ol>
<p>其实这个地方随机数只是为了负载均衡策略，不会有这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Join</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造函数创建的 Random 实例的 seed 是当年的 纳秒时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DivideUpstream <span class="title">doSelect</span><span class="params">(<span class="keyword">final</span> List&lt;DivideUpstream&gt; upstreamList, <span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//计算出总权重数</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = calculateTotalWeight(upstreamList);</span><br><span class="line">        <span class="comment">//检查所有的 upstreams 分配到的权重是否完全相等</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = isAllUpStreamSameWeight(upstreamList);</span><br><span class="line">        <span class="comment">//如果总权重数 &gt; 0 且 upstream 分配到的权重都不相等</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">        	<span class="comment">// 返回选择的 upstream</span></span><br><span class="line">            <span class="keyword">return</span> random(totalWeight, upstreamList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the weights are the same or the weights are 0 then random</span></span><br><span class="line">        <span class="comment">// 如果 upstreams 分配到的权重完全相等，或者 总权重数 = 0</span></span><br><span class="line">        <span class="keyword">return</span> random(upstreamList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAllUpStreamSameWeight</span><span class="params">(<span class="keyword">final</span> List&lt;DivideUpstream&gt; upstreamList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> length = upstreamList.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(upstreamList.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; weight != getWeight(upstreamList.get(i - <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 依次和前一个比较权重是否相等，如果不等就跳出当前循环</span></span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sameWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateTotalWeight</span><span class="params">(<span class="keyword">final</span> List&lt;DivideUpstream&gt; upstreamList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// total weight</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DivideUpstream divideUpstream : upstreamList) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(divideUpstream);</span><br><span class="line">            <span class="comment">// 计算总权重数</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DivideUpstream <span class="title">random</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> totalWeight, <span class="keyword">final</span> List&lt;DivideUpstream&gt; upstreamList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the weights are not the same and the weights are greater than 0, then random by the total number of weights</span></span><br><span class="line">        <span class="keyword">int</span> offset = RANDOM.nextInt(totalWeight);</span><br><span class="line">        <span class="comment">// Determine which segment the random value falls on</span></span><br><span class="line">        <span class="keyword">for</span> (DivideUpstream divideUpstream : upstreamList) &#123;</span><br><span class="line">            offset -= getWeight(divideUpstream);</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> divideUpstream;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> upstreamList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DivideUpstream <span class="title">random</span><span class="params">(<span class="keyword">final</span> List&lt;DivideUpstream&gt; upstreamList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upstreamList.get(RANDOM.nextInt(upstreamList.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是 一个巧妙的负载均衡策略：RoundRobinLoadBalance，首先我们来了解一下相关的概念：</p>
<p>Nginx 的负载均衡调度算法默认就是 round robin，也就是轮询调度算法。根据维基百科的介绍：术语循环/轮转/轮替（英语：Round-robin）用于多种情况中，通常指将多个某物轮流用于某事，例如“逐户派对”（round-robin-party）中所有参与者要挨家挨户地拜访每位参与者的住处并参加那里的小型聚会。联名信（round-robin letter）往往是指一大群下属为批评其领导而写的一封信，这种信一般只在签名人数多到难于逐个报复后才会寄出。</p>
<p>在负载均衡算法上的应用，也就是由 upstreams 轮流来处理请求，但在 Soul 中 是加权轮询调度的，查阅<a href="https://www.nginx.com/resources/glossary/round-robin-load-balancing/" target="_blank" rel="noopener">Nginx 官方文档关于轮询调度算法的文章</a>，发现对加权轮询调度有以下的解释：</p>
<p>Weighted round robin – A weight is assigned to each server based on criteria chosen by the site administrator; the most commonly used criterion is the server’s traffic‑handling capacity. The higher the weight, the larger the proportion of client requests the server receives. If, for example, server A is assigned a weight of 3 and server B a weight of 1, the load balancer forwards 3 requests to server A for each 1 it sends to server B.</p>
<p>加权轮询是根据站点管理员选择的标准为每个服务器分配一个权重的策略。最常用的标准是服务器的流量处理能力。权重越高，服务器接收的客户端请求的比例越大。例如，如果为服务器A分配了3的权重，为服务器B分配了1的权重，那么负载均衡器每向服务器B转发 1 个请求，就会向服务器A转发 3 个请求，因为服务器A权重更高，代表他处理流量的能力更强。</p>
<p>加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。</p>
<p>下面我们深入源码来看是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Join</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收周期为 60000 毫秒，即 60 秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> recyclePeriod = <span class="number">60000</span>;</span><br><span class="line">	<span class="comment">//函数权重 map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">	<span class="comment">//更新锁，用 AtomicBoolean 实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean updateLock = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DivideUpstream <span class="title">doSelect</span><span class="params">(<span class="keyword">final</span> List&lt;DivideUpstream&gt; upstreamList, <span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">        String key = upstreamList.get(<span class="number">0</span>).getUpstreamUrl();</span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="comment">//将 第一个 upstream url 放入 函数权重 map</span></span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            methodWeightMap.putIfAbsent(key, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line">            map = methodWeightMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        DivideUpstream selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (DivideUpstream upstream : upstreamList) &#123;</span><br><span class="line">            String rKey = upstream.getUpstreamUrl();</span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = map.get(rKey);</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(upstream);</span><br><span class="line">            <span class="comment">//如果 weightedRoundRobin 为 null，则实例化一个新的 WeightedRoundRobin，放入 map 中</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="keyword">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                map.putIfAbsent(rKey, weightedRoundRobin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                <span class="comment">// 如果权重不一致，则更新</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前权重加到 current 中</span></span><br><span class="line">            <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">//设置最后更新时间</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">//如果两个权重相等，则第一个被遍历的会被选中</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                <span class="comment">// 如果当前值大于最大值，则更新最大值</span></span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                <span class="comment">// 确定当前 upstream 为被选中的调用者</span></span><br><span class="line">                selectedInvoker = upstream;</span><br><span class="line">                <span class="comment">//被选择的加权轮询调度</span></span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总权重数汇总</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果更新锁未被持有且 upstreamList 大小与 map 不一致且 加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; upstreamList.size() != map.size() &amp;&amp; updateLock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 复制一份 map，然后遍历 newMap 并移除 当前时间减去最后更新时间大于 60秒的元素</span></span><br><span class="line">                ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(map);</span><br><span class="line">                newMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; recyclePeriod);</span><br><span class="line">                <span class="comment">// 再将 key 指向新的 newMap</span></span><br><span class="line">                methodWeightMap.put(key, newMap);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            	<span class="comment">//最后施放锁</span></span><br><span class="line">                updateLock.set(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//被选中的 weighted round robin 的 current 减去总节点权重分</span></span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> upstreamList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>光看代码，逻辑还是有点不清晰，假设我们有三个节点ABC，权重分别是 5，3，2，在7次请求的情况下：</p>
<table>
<thead>
<tr>
<th>请求次数</th>
<th>请求前weight</th>
<th>current</th>
<th>选中节点</th>
<th>请求后weight</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A=5,B=3,C=2</td>
<td>5</td>
<td>A</td>
<td>A=0,B=6,C=4</td>
</tr>
<tr>
<td>2</td>
<td>A=0,B=6,C=4</td>
<td>6</td>
<td>B</td>
<td>A=5,B=2,C=6</td>
</tr>
<tr>
<td>3</td>
<td>A=5,B=2,C=6</td>
<td>6</td>
<td>C</td>
<td>A=10,B=5,C=-1</td>
</tr>
<tr>
<td>4</td>
<td>A=10,B=5,C=-1</td>
<td>10</td>
<td>A</td>
<td>A=6,B=8,C=1</td>
</tr>
<tr>
<td>5</td>
<td>A=6,B=8,C=1</td>
<td>8</td>
<td>B</td>
<td>A=11,B=1,C=3</td>
</tr>
<tr>
<td>6</td>
<td>A=11,B=1,C=3</td>
<td>11</td>
<td>A</td>
<td>A=7,B=4,C=5</td>
</tr>
<tr>
<td>7</td>
<td>A=7,B=4,C=5</td>
<td>7</td>
<td>A</td>
<td>A=-2,B=7,C=7</td>
</tr>
<tr>
<td>我们可以看到第 7 次 请求后的 权重 B 和 C 都是7，如何分配呢？答案就在源码中</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">    maxCurrent = cur;</span><br><span class="line">    selectedInvoker = upstream;</span><br><span class="line">    selectedWRR = weightedRoundRobin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个被遍历的 upstream 会被选中，所以下一次请求将会转发到 B 节点上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RoundRobinLoadBalance 在设计上跟 Nginx 是类似的，我们可以理解为工作效率越高的程序员接的活越多，责任也越大，因为他在领导心中的权重最高。🤣<br>加锁使用 AtomicBoolean 实现，有效降低了锁的开销。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interview</tag>
      </tags>
  </entry>
</search>
