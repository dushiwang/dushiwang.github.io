<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARTS-01</title>
    <url>/2019/06/30/ARTS-01/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>Two Sum 两数之和（leetcode #1）</p>
<p>“平生不识 TwoSum，刷尽 LeetCode 也枉然。”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span><br><span class="line"></span><br><span class="line">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：<br>本题的要求是找到两数之和等于 target 的以这两个数的下表为元素的数组，初步的想法应该用HashMap 存下遍历 nums数组的下表与对应的值，并且判断当 用target减去 已存在的数得到数组中另一个数时，满足题目的要求，返回他们的下标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        int[] result &#x3D; new int[2];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[0] &#x3D; map.get(target - nums[i]);</span><br><span class="line">                result[1] &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><strong>Top Signs of an Over-Experienced Programmer</strong><br><a href="https://medium.com/better-programming/top-signs-of-an-over-experienced-programmer-22bbe0b57663" target="_blank" rel="noopener">https://medium.com/better-programming/top-signs-of-an-over-experienced-programmer-22bbe0b57663</a></p>
<p>只要我们还是programmer 我们的重心还是要放到programming 与 engineering 上，过度地考虑需求是否合理，项目是否能满足用户需求等并不是我们需要考虑的重心。我们需要避免不必要的refactoring，以尽可能perfect地实现需求为目标，深入到code engineering才是。</p>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p><strong>本周在做新项目时又重新用到了 hibernate mybatis 和 jdbcTemplate。下面针对这些工具我个人的一些看法</strong></p>
<ul>
<li>hibernate 虽然比较方便，结合Spring Data JPA 可以非常方便的写出crud逻辑，但缺点也非常明显，就是相对其他两个来说太不灵活了，如果不小心开启了自动生成数据库的配置，自动生成的外键够让你难受的了。</li>
<li>mybatis 使用起来中规中矩，但还是不够灵活，仿佛掉进了维护数据表间关系的坑里。</li>
<li>jdbcTemplate 我用得最顺手，特别是 NamedParameterJdbcTemplate，通过手动拼接SQL实现复杂的逻辑非常好用，还不必像在PreparedStatement中一样数问号🤣</li>
</ul>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p><strong>本周分享的文章是来自 阿里云云栖社区 的一篇关于HashMap的文章</strong><br>由阿里巴巴Java开发规约HashMap条目引发的故事<br><a href="https://zhuanlan.zhihu.com/p/30360734" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30360734</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-02.md</title>
    <url>/2019/07/14/ARTS-02/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>Print in Order（1114）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Suppose we have a class:</span><br><span class="line"></span><br><span class="line">public class Foo &#123;</span><br><span class="line">  public void one() &#123; print(&quot;one&quot;); &#125;</span><br><span class="line">  public void two() &#123; print(&quot;two&quot;); &#125;</span><br><span class="line">  public void three() &#123; print(&quot;three&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">The same instance of Foo will be passed to three different threads. Thread A will call one(), thread B will call two(), and thread C will call three(). Design a mechanism and modify the program to ensure that two() is executed after one(), and three() is executed after two().</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;print-in-order</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong>：<br>leetcode关于多线程的新题，考察多线程中的按序执行。<br>可以用以下方法解：</p>
<ol>
<li>利用CountDownLatch 来控制执行的顺序。</li>
<li>利用volatile 创建全局可见的变量，通过对该变量的原子性更新来保证执行顺序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">    private CountDownLatch c2;</span><br><span class="line">    private CountDownLatch c3;</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        c2 &#x3D; new CountDownLatch(1);</span><br><span class="line">        c3 &#x3D; new CountDownLatch(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">        printFirst.run();</span><br><span class="line">        c2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        c2.await();</span><br><span class="line">        &#x2F;&#x2F; printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        printSecond.run();</span><br><span class="line">        c3.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        c3.await();</span><br><span class="line">        &#x2F;&#x2F; printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile int flag &#x3D; 1;</span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">        printFirst.run();</span><br><span class="line">        flag &#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        while(flag !&#x3D; 2);</span><br><span class="line">        &#x2F;&#x2F; printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        printSecond.run();</span><br><span class="line">        flag &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        while(flag !&#x3D; 3);</span><br><span class="line">        &#x2F;&#x2F; printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><strong>Faircode, an alternative to Open Source that aims to get developers paid</strong><br><a href="https://hackernoon.com/faircode-an-alternative-to-open-source-89cdc65df3fa" target="_blank" rel="noopener">https://hackernoon.com/faircode-an-alternative-to-open-source-89cdc65df3fa</a></p>
<p>在2017年作者提出了Faircode这个概念，旨在给开发者一个新的盈利方式。不同于“闭源软件”，Faircode 打算以向大公司收费而对小公司免费的形势获利。然而不幸的是，作者发起的Faircode 及相关的license 已经被删除了。作者想法在当时比较前卫，可能在推行的过程中成效不大吧。</p>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p><a href="https://javarevisited.blogspot.com/2018/05/10-tips-to-become-better-java-developer.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2018/05/10-tips-to-become-better-java-developer.html</a></p>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>JAVA 注解的基本原理</p>
<p><a href="https://juejin.im/post/5b45bd715188251b3a1db54f" target="_blank" rel="noopener">https://juejin.im/post/5b45bd715188251b3a1db54f</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-03</title>
    <url>/2019/07/26/ARTS-03/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>Add Two Numbers(#2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;2 lang&#x3D;java</span><br><span class="line"> *</span><br><span class="line"> * [2] 两数相加</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode pre &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; pre;</span><br><span class="line">        int carry &#x3D; 0;</span><br><span class="line">        while (l1 !&#x3D; null || l2 !&#x3D; null) &#123;</span><br><span class="line">            int x &#x3D; l1 &#x3D;&#x3D; null ? 0 : l1.val;</span><br><span class="line">            int y &#x3D; l2 &#x3D;&#x3D; null ? 0 : l2.val;</span><br><span class="line">            int sum &#x3D; x + y + carry;</span><br><span class="line">            </span><br><span class="line">            carry &#x3D; sum &#x2F; 10;</span><br><span class="line">            sum &#x3D; sum % 10;</span><br><span class="line">            cur.next &#x3D; new ListNode(sum);</span><br><span class="line"></span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">            if (l1 !&#x3D; null) &#123;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (l2 !&#x3D; null) &#123;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            cur.next &#x3D; new ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        return pre.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题我们可以创建一个辅助节点pre 再用一个节点cur指向我们正在进行计算的结果链表上的节点。</p>
<p>通过对l1, l2这两条链做遍历，我们可以获得l1, l2 当前节点的值x 和 y，可以计算出他们与进位标识（变量carry，初始值为0）的和sum。可以通过对carry被10整除的余数来得知当前节点的两数相加是否进位。通过对sum的值对10取mod，可以得到加了进位后的值。</p>
<p>之后就是创建辅助节点链的后一个节点，并把cur指向新节点。如果这次运算有进位，则再新增一个值为carry的节点。 这样重复直到l1 或 l2到达链尾，如果不同时到达链尾，则结果链表依次把未到达链尾的数复制，最后l1，l2都到达链尾，计算结束。</p>
<h3 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h3><p><strong>Python at Netflix</strong></p>
<p><a href="https://medium.com/netflix-techblog/python-at-netflix-bba45dae649e" target="_blank" rel="noopener">https://medium.com/netflix-techblog/python-at-netflix-bba45dae649e</a></p>
<p>这篇文章主要介绍了Python在Netflix技术架构中的应用。给想要用Python搞事情的朋友们一些有事实支持的思路。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>本周分享一下Java内存模型的happen before原则</p>
<ol>
<li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作happens before于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。如果在一个线程的操作，那么前一个操作的结果必定对后续操作可见。</li>
<li>管程锁定规则：一个unlock操作happens before于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。最常见的就是syncronized 方法和syncronized代码块。</li>
<li>volatile变量规则：对一个volatile变量的写操作happens before于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。该规则在ConcurrentHashMap 中读操作不需要加锁中有很好的体现。</li>
<li>线程启动规则：Thread对象的start()方法happens before于此线程的每一个动作。</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</li>
</ol>
<p>传递性：如果 A happens before B，且B happens before C，则A happens before C</p>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>打造 Mac 下高颜值好用的终端环境</p>
<p><a href="https://blog.biezhi.me/2018/11/build-a-beautiful-mac-terminal-environment.html" target="_blank" rel="noopener">https://blog.biezhi.me/2018/11/build-a-beautiful-mac-terminal-environment.html</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-04</title>
    <url>/2019/08/02/ARTS-04/</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>无重复字符的最长子串(3)</p>
<p><strong>解法1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=3 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [3] 无重复字符的最长子串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= l; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allUnique(s, i, j)) &#123;</span><br><span class="line">                    result = Math.max(result, j - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            Character c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(c)) &#123;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力破解法没啥好说的, 直接超时了, 显然是不可行的.<br>时间复杂度：O(n^3)</p>
<p><strong>解法2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中接口与抽象类的区别</title>
    <url>/2019/07/02/Java-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>如果一个类有抽象方法，则称这个类为抽象类。使用abstract修饰抽象类。<br>抽象类中可能含有无具体实现的方法，故不能用抽象类创建对象。抽象方法是一种特殊的方法，只有声明，没有实现。如果一个类继承抽象类，则必须实现父类的抽象方法，如果不这么做，则此类也应该为抽象类。</p>
<h5 id="抽象类与普通类的区别"><a href="#抽象类与普通类的区别" class="headerlink" title="抽象类与普通类的区别"></a>抽象类与普通类的区别</h5><ol>
<li>抽象方法的访问修饰符必须为public 或者 protected（如果为private 则不能被子类继承，子类无法实现该方法），默认为public。</li>
<li>抽象类不能用来创建对象。</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的所有抽象方法。如果子类没有实现，则必须定义为abstract class。</li>
</ol>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>可以含有变量和方法。<br>但是接口中非default的方法是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract（1.8以后可以是default），其他修饰符都会报错）。<br>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</p>
<h5 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h5><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。(Java 1.8以后接口可以有可以实现的default方法)</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Exception &amp; Error</title>
    <url>/2019/05/22/Java-Exception-Error/</url>
    <content><![CDATA[<p>###java.lang.ClassNotFoundException</p>
<p>This exception indicates that the class was not found on the classpath. This indicates that we were trying to load the class definition, and the class did not exist on the classpath.</p>
<p>###java.lang.NoClassDefFoundError<br>This exception indicates that the JVM looked in its internal class definition data structure for the definition of a class and did not find it. This is different than saying that it could not be loaded from the classpath. Usually this indicates that we previously attempted to load a class from the classpath, but it failed for some reason - now we’re trying to use the class again (and thus need to load it, since it failed last time), but we’re not even going to try to load it, because we failed loading it earlier (and reasonably suspect that we would fail again). The earlier failure could be a ClassNotFoundException or an ExceptionInInitializerError (indicating a failure in the static initialization block) or any number of other problems. The point is, a NoClassDefFoundError is not necessarily a classpath problem.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis八股文</title>
    <url>/2020/09/03/Redis%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h2 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h2><ol>
<li>Redis 有哪些数据结构，分别有什么使用场景？</li>
<li>Redis ZSET 相同 score 如何排序？</li>
<li>在爬虫中，如何使用 Redis 做 URL 去重？</li>
<li>Redis 是否支持事务？</li>
<li>Redis 中的 WATCH 命令是做什么的？</li>
<li>Redis 是如何保证高可用的？</li>
<li>如何使用 Redis 来实现分布式锁？Redlock？</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（二）divide, rewrite 插件</title>
    <url>/2021/01/16/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89divide-rewrite-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一节里我们编译好了 Soul 网关的源码，今天我们从rewrite插件开始学习如何对服务进行代理并重写路径。</p>
<a id="more"></a>

<p>首先我们用Python写一个简单的Flask应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/foo/bar/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>启动服务后，我们可以看到现在设置的路径为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;foo&#x2F;bar&#x2F;</span><br></pre></td></tr></table></figure>
<p>尝试使用 curl 访问对应的接口：<br><img src="https://img-blog.csdnimg.cn/20210115211421555.png" alt="在这里插入图片描述"><br>OK，服务正常。</p>
<p>我们在 soul-admin 选择 <strong>rewrite</strong> 插件，点击添加选择器：<br><img src="https://img-blog.csdnimg.cn/20210115210809657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="选择添加选择器"><br>在弹出的对话框中输入：<br><img src="https://img-blog.csdnimg.cn/20210115211626802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击确认后，通过 Chrome debug 可以捕获到前端发起的三个请求，分别是：</p>
<ol>
<li>/selector</li>
<li>/selector?pluginId=3&amp;currentPage=1&amp;pageSize=12</li>
<li>/rule?currentPage=1&amp;pageSize=12&amp;selectorId=1350069791219036160</li>
</ol>
<p>我们追踪到对应的源码可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * query Selectors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pluginId    plugin id.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentPage current page.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize    page size.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@linkplain</span> SoulAdminResult&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SoulAdminResult <span class="title">querySelectors</span><span class="params">(<span class="keyword">final</span> String pluginId, <span class="keyword">final</span> Integer currentPage, <span class="keyword">final</span> Integer pageSize)</span> </span>&#123;</span><br><span class="line">    CommonPager&lt;SelectorVO&gt; commonPager = selectorService.listByPage(<span class="keyword">new</span> SelectorQuery(pluginId, <span class="keyword">new</span> PageParameter(currentPage, pageSize)));</span><br><span class="line">    <span class="keyword">return</span> SoulAdminResult.success(SoulResultMessage.QUERY_SUCCESS, commonPager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两个请求其实是在加载我们右侧的选择器，现在我们没有创建选择器，所以什么也没有。<br>而 /rule 这个请求是在查询现有的规则列表。</p>
<p>点击右侧的“创建选择器”按钮来创建选择器：<br><img src="https://img-blog.csdnimg.cn/20210115213000568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建好选择器后，由于我们仅仅是把选择器的数据存放在了 数据库中（根据你配置可能在 MySQL 或 H2里），我们如果需要他即时生效需要点击同步自定义rewrite。<br><img src="https://img-blog.csdnimg.cn/20210115213237513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接口调用路径是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9095&#x2F;plugin&#x2F;syncPluginData&#x2F;3</span><br></pre></td></tr></table></figure>
<p>返回 “sync success”，我们再次切换到源码：<br><img src="https://img-blog.csdnimg.cn/20210115213635126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现 soul-admin 用到了Spring 中的 ApplicationEventPublisher，在如下路径的类中，我们也找到了soul-admin处理这些时间的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org&#x2F;dromara&#x2F;soul&#x2F;admin&#x2F;listener&#x2F;DataChangedEventDispatcher.java</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210115214219112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>刚刚我们应该是通过点击按钮触发了 “onPluginChanged” 这个事件，可以看到，根据我们所配置的数据同步侧录额，soul 提供了三种实现方式：<br><img src="https://img-blog.csdnimg.cn/20210115214458570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p>WebSocket<br> 在 WebsocketDataChangedListener 中调用 onPluginChanged 方法来向 SoulBootstrapApplication 发送JSON序列化后的消息。</p>
</li>
<li><p>Nacos<br> 如果配置 Nacos 进行同步，则是通过 ConfigService 来发送消息。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">     updatePluginMap(getConfig(PLUGIN_DATA_ID));</span><br><span class="line">     <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">         <span class="keyword">case</span> DELETE:</span><br><span class="line">             changed.forEach(plugin -&gt; PLUGIN_MAP.remove(plugin.getName()));</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> REFRESH:</span><br><span class="line">         <span class="keyword">case</span> MYSELF:</span><br><span class="line">             Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(PLUGIN_MAP.keySet());</span><br><span class="line">             changed.forEach(plugin -&gt; &#123;</span><br><span class="line">                 set.remove(plugin.getName());</span><br><span class="line">                 PLUGIN_MAP.put(plugin.getName(), plugin);</span><br><span class="line">             &#125;);</span><br><span class="line">             PLUGIN_MAP.keySet().removeAll(set);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             changed.forEach(plugin -&gt; PLUGIN_MAP.put(plugin.getName(), plugin));</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     publishConfig(PLUGIN_DATA_ID, PLUGIN_MAP);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ZooKeeper<br>  通过节点同步数据。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; changed, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (PluginData data : changed) &#123;</span><br><span class="line">           <span class="keyword">final</span> String pluginPath = ZkPathConstants.buildPluginPath(data.getName());</span><br><span class="line">           <span class="comment">// delete</span></span><br><span class="line">           <span class="keyword">if</span> (eventType == DataEventTypeEnum.DELETE) &#123;</span><br><span class="line">               deleteZkPathRecursive(pluginPath);</span><br><span class="line">               <span class="keyword">final</span> String selectorParentPath = ZkPathConstants.buildSelectorParentPath(data.getName());</span><br><span class="line">               deleteZkPathRecursive(selectorParentPath);</span><br><span class="line">               <span class="keyword">final</span> String ruleParentPath = ZkPathConstants.buildRuleParentPath(data.getName());</span><br><span class="line">               deleteZkPathRecursive(ruleParentPath);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//create or update</span></span><br><span class="line">           upsertZkNode(pluginPath, data);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过对指定接口发起 POST 请求来注册其他语言的服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;appName&quot;: &quot;xxx&quot;, &#x2F;&#x2F;应用名称 必填</span><br><span class="line">	&quot;context&quot;: &quot;&#x2F;xxx&quot;, &#x2F;&#x2F;请求前缀 必填</span><br><span class="line">	&quot;path&quot;: &quot;xxx&quot;, &#x2F;&#x2F;路径需要唯一 必填</span><br><span class="line">	&quot;pathDesc&quot;: &quot;xxx&quot;, &#x2F;&#x2F;路径描述</span><br><span class="line">	&quot;rpcType&quot;: &quot;http&quot;, &#x2F;&#x2F;rpc类型  必填</span><br><span class="line">	&quot;host&quot;: &quot;xxx&quot;, &#x2F;&#x2F;服务host 必填</span><br><span class="line">	&quot;port&quot;: xxx, &#x2F;&#x2F;服务端口 必填</span><br><span class="line">	&quot;ruleName&quot;: &quot;xxx&quot;, &#x2F;&#x2F;可以同path一样  必填</span><br><span class="line">	&quot;enabled&quot;: &quot;true&quot;, &#x2F;&#x2F;是否开启</span><br><span class="line">	&quot;registerMetaData&quot;: &quot;true&quot; &#x2F;&#x2F;是否需要注册元数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">请求地址：http:&#x2F;&#x2F;&#123;ip&#125;:&#123;port&#125;&#x2F;soul-client&#x2F;springmvc-register 请自行输入soul-admin 的 IP 和 PORT</span><br></pre></td></tr></table></figure>
<p>在 postman 或其他工具中成功注册服务：<br><img src="https://img-blog.csdnimg.cn/20210116013439579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但我们发现并不能直接通过 soul 来代理我们的 flask 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl http:&#x2F;&#x2F;localhost:9195</span><br><span class="line">&#123;&quot;code&quot;:-107,&quot;message&quot;:&quot;Can not find selector, please check your configuration!&quot;,&quot;data&quot;:null&#125;%</span><br></pre></td></tr></table></figure>
<p>仔细查看文档后，发现需要先设置 Divide 插件并添加对应的selector。<br><img src="https://img-blog.csdnimg.cn/20210116014205816.png" alt="在这里插入图片描述"><br>配置完成后可以看到 divide 插件成功选取到了 我们配置的 test1 selector，但是我们的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:9195&#x2F;foo&#x2F;bar&#x2F;</span><br></pre></td></tr></table></figure>
<p>被解析成了 <a href="http://127.0.0.1:5000/bar/，一定是什么地方出了问题。" target="_blank" rel="noopener">http://127.0.0.1:5000/bar/，一定是什么地方出了问题。</a><br>再看看源码<br><img src="https://img-blog.csdnimg.cn/20210116015548504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们发现 在 org/dromara/soul/plugin/divide/DividePlugin.java 这个类中 buildRealURL 会将我们的 “/foo” 识别为 module，然后把“/bar” 识别为真实的request path，所以导致了刚刚的问题。<br>再次尝试在前面加一层，成功了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl http:&#x2F;&#x2F;localhost:9195&#x2F;1&#x2F;foo&#x2F;bar&#x2F;</span><br><span class="line">Hello World!%</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js双向数据绑定探究</title>
    <url>/2018/08/03/Vue-js%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在最近的前端面试中，vue.js的双向数据绑定基本是我必问的。下面我们就一起探究下其原理。</p>
<a id="more"></a>

<p><img src="https://i.imgur.com/bKNikGl.jpg" alt=""></p>
<ol>
<li>原理<br>Vue.js双向数据绑定的原理主要是通过 <strong>Object对象的defineProperty方法，重写data的set和get函数</strong> 来实现的。<br>以下是defineProperty()的语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>
这个方法的三个参数分别是：</li>
</ol>
<ul>
<li>obj<br>要在其上定义属性的对象。</li>
<li>prop<br>要定义或修改的属性的名称。</li>
<li>descriptor<br>将被定义或修改的属性描述符。</li>
</ul>
<p>方法相关的就不在这里讨论，详见：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p>
]]></content>
      <categories>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>hello_world</title>
    <url>/2018/04/15/hello-world/</url>
    <content><![CDATA[<h4 id="终于有了自己的博客了"><a href="#终于有了自己的博客了" class="headerlink" title="终于有了自己的博客了"></a>终于有了自己的博客了</h4>]]></content>
      <tags>
        <tag>mixture</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql生成批量语句</title>
    <url>/2018/04/28/mysql%E7%94%9F%E6%88%90%E6%89%B9%E9%87%8F%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>今天遇到监控系统的表格太多的问题, 为了节约时间, 在网上找到了生成批量删除表的语句:</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT( &#39;drop table &#39;, table_name, &#39;;&#39; )</span><br><span class="line">FROM information_schema.tables</span><br><span class="line">WHERE table_name LIKE &#39;pre_%&#39;;</span><br></pre></td></tr></table></figure>
<p>这样可以批量生成drop 语句, 使用navicat执行即可.</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h3><p>十分钟了结MySQL information_schema</p>
<p><a href="https://www.cnblogs.com/shengdimaya/p/6920677.html" target="_blank" rel="noopener">https://www.cnblogs.com/shengdimaya/p/6920677.html</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>php 在Windows开发下遇到的坑</title>
    <url>/2018/04/15/php-%E5%9C%A8Windows%E5%BC%80%E5%8F%91%E4%B8%8B%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>在本地调试php通过使用php的curl 调用Thrift rpc 服务时, 使用了curl, 但是一直出现超时的现象,一直到超过请求所附带的超时时间, 这个是因为Windows下的php是以php-cgi进程的形式运行的.</p>
<a id="more"></a>

<p>我的php项目的fastcig-pass的设置为(127.0.0.1:9000)。</p>
<p>默认设置是以keepalive方式请求，接收到PHP文件时,交与php-cgi解析处理,等待响应。</p>
<p>而在本地文件以CURL请求本地环境中PHP文件时,之前的PHP还在等待CURL后的结果，这时9000端口已经被占用.导致CURL一直在处于等待状态.</p>
<p>curl 其中一项设置: </p>
<p>curl_setopt($ch, CURLOPT_TIMEOUT, 5);</p>
<p>当到达5秒后, curl 被强制中断, 反而收到了RPC传来的response</p>
<p>在查阅资料后, 我发现Windows 中php-cgi并不能像Linux环境下的php-fpm 那样自己创建新的进程, 只能通过command的方式启动两个进程…</p>
<p><strong>我的解决方案</strong></p>
<p>把php客户端的fastcgi_pass 设置为了127.0.0.1:9004</p>
<p>打开两个cmd 分别在php根目录下执行这两个命令:</p>
<ol>
<li>php-cgi.exe -b 127.0.0.1:9000 -c php.ini </li>
<li>php-cgi.exe -b 127.0.0.1:9004 -c php.ini </li>
</ol>
<p>但是cmd 命令窗口不能关闭。</p>
<p>问题解决.</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>traps</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（三）dubbo 插件</title>
    <url>/2021/01/17/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89dubbo-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一节中，我们尝试使用divide插件进行http代理，今天我们来看看Soul是如何将http协议，转换成dubbo协议的。</p>
<a id="more"></a>

<p>首先在插件管理中开启dubbo配置：<br><img src="https://img-blog.csdnimg.cn/20210117003330559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开Soul 源码，编译下图路径的dubbo demo 项目：<br><img src="https://img-blog.csdnimg.cn/20210117003428606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>编译后我们把打包好的 Jar 包run起来，<br>确保</p>
<ol>
<li>dubbo 插件已开启</li>
<li>你的soul-bootstrap，soul-admin 在运行状态</li>
<li>zookeeper 也在启动状态（默认端口2181），地址在：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soul&#x2F;soul-examples&#x2F;soul-examples-dubbo&#x2F;soul-examples-alibaba-dubbo-service&#x2F;target&#x2F;soul-examples-alibaba-dubbo-service-2.1.0.jar</span><br></pre></td></tr></table></figure>
成功运行dubbo demo 后，发现soul admin 帮我们注册了其中的 endpoints<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-01-17 00:51:50.563  INFO 63416 --- [-47-EventThread] o.a.c.f.state.ConnectionStateManager     : State change: CONNECTED</span><br><span class="line">2021-01-17 00:51:50.590  INFO 63416 --- [-47-EventThread] o.a.c.framework.imps.EnsembleTracker     : New config event received: &#123;&#125;</span><br><span class="line">2021-01-17 00:51:50.590  INFO 63416 --- [-47-EventThread] o.a.c.framework.imps.EnsembleTracker     : New config event received: &#123;&#125;</span><br><span class="line">2021-01-17 00:51:50.973  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397137501040640, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;insert, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboTestService, methodName&#x3D;insert, parameterTypes&#x3D;org.dromara.soul.examples.dubbo.api.entity.DubboTest, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:50.993  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397138167934976, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findAll, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboTestService, methodName&#x3D;findAll, parameterTypes&#x3D;null, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.012  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397138960658432, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findById, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboTestService, methodName&#x3D;findById, parameterTypes&#x3D;java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.060  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139031961600, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByIdsAndName, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByIdsAndName, parameterTypes&#x3D;java.util.List,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.079  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139103264768, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByArrayIdsAndName, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByArrayIdsAndName, parameterTypes&#x3D;[Ljava.lang.Integer;,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.100  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139182956544, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByStringArray, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByStringArray, parameterTypes&#x3D;[Ljava.lang.String;, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.126  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139258454016, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;findByListId, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;findByListId, parameterTypes&#x3D;java.util.List, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.153  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139346534400, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;batchSave, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;batchSave, parameterTypes&#x3D;java.util.List, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.169  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139413643264, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;batchSaveAndNameAndId, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;batchSaveAndNameAndId, parameterTypes&#x3D;java.util.List,java.lang.String,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.186  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139476557824, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;saveComplexBeanTest, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;saveComplexBeanTest, parameterTypes&#x3D;org.dromara.soul.examples.dubbo.api.entity.ComplexBeanTest, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br><span class="line">2021-01-17 00:51:51.201  INFO 63416 --- [ctReadThread-47] o.d.s.p.a.d.c.ApplicationConfigCache     : init aliaba dubbo reference success there meteData is :MetaData(id&#x3D;1350397139547860992, appName&#x3D;dubbo, contextPath&#x3D;null, path&#x3D;&#x2F;dubbo&#x2F;saveComplexBeanTestAndName, rpcType&#x3D;dubbo, serviceName&#x3D;org.dromara.soul.examples.dubbo.api.service.DubboMultiParamService, methodName&#x3D;saveComplexBeanTestAndName, parameterTypes&#x3D;org.dromara.soul.examples.dubbo.api.entity.ComplexBeanTest,java.lang.String, rpcExt&#x3D;&#123;&quot;group&quot;:&quot;&quot;,&quot;version&quot;:&quot;&quot;,&quot;loadbalance&quot;:&quot;random&quot;,&quot;retries&quot;:2,&quot;timeout&quot;:10000,&quot;url&quot;:&quot;&quot;&#125;, enabled&#x3D;true)</span><br></pre></td></tr></table></figure>
使用curl 调用 soul-bootstrap 代理的接口：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl localhost:9195&#x2F;dubbo&#x2F;findAll </span><br><span class="line">&#x2F;&#x2F;返回了</span><br><span class="line">&#123;&quot;code&quot;:200,&quot;message&quot;:&quot;Access to success!&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;hello world Soul Alibaba Dubbo , findAll&quot;,&quot;id&quot;:&quot;654524173&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
表明我们通过soul成功调用了dubbo的接口。</li>
</ol>
<p>深入源码，在调用 “/dubbo/findAll” 这个路径时，dubbo plugin 执行了 doExecute 方法，然后从 ServerWebExchange 中分别获取到了<br>soulContext 和 metaData：<br><img src="https://img-blog.csdnimg.cn/202101170117309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210117011809380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在这两个对象中我们已经看到了即将调用到的DubboTestService和 对应的方法名 findAll。<br>在这里我们获取到了 genericService，并将封装好的方法名，参数通过 genericService 的 $invoke方法调用真实的dubbo服务endpoint，再将response 返回给soul-bootstrap这边。<br><img src="https://img-blog.csdnimg.cn/20210117012348487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：Dubbo插件非常强大，能够通过扫描zookeeper的方式将所有已注册的endpoint 并直接添加到规则中，这一点对于dubbo用户来说接入几乎是零成本的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（四）sign 插件</title>
    <url>/2021/01/19/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89sign-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一节中，我们尝试dubbo插件将http协议转换成dubbo协议，今天我们来看看 sign 插件是如何实现请求鉴权的。</p>
<a id="more"></a>
<h1 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h1><p>我们先试试没有添加sign插件时，是否能正常请求接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl localhost:9195&#x2F;dubbo&#x2F;findAll</span><br><span class="line">&#123;&quot;code&quot;:200,&quot;message&quot;:&quot;Access to success!&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;hello world Soul Alibaba Dubbo , findAll&quot;,&quot;id&quot;:&quot;-803129909&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>成功。</p>
<p>首先我们需要在插件管理中打开sign插件的开关。然后我们在认证管理中，新增一条 AK/SK 记录：<br><img src="https://img-blog.csdnimg.cn/20210119004613292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加完毕后，我们可以看到AppKey 和加密密钥已经为我们生成好了：<br><img src="https://img-blog.csdnimg.cn/20210119004712413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们再试试刚刚代理dubbo 服务中的 /dubbo/findAll 接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl localhost:9195&#x2F;dubbo&#x2F;findAll</span><br><span class="line">&#123;&quot;code&quot;:200,&quot;message&quot;:&quot;Access to success!&quot;,&quot;data&quot;:&#123;&quot;name&quot;:&quot;hello world Soul Alibaba Dubbo , findAll&quot;,&quot;id&quot;:&quot;-541002115&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>发现没有生效，原因是没有配置sign的选择器：<br><img src="https://img-blog.csdnimg.cn/20210119010246549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021011901033031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210119010334975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按照上图所示配置好sign选择器后再请求我们配置了鉴权校验的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl localhost:9195&#x2F;dubbo&#x2F;findAll</span><br><span class="line">&#123;&quot;code&quot;:401,&quot;message&quot;:&quot;sign parameters are incomplete!&quot;,&quot;data&quot;:null&#125;</span><br></pre></td></tr></table></figure>
<p>成了，提示我们签名参数不完整，下表展示了我们需要在headers中添加的header：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp</td>
<td>1571711067186</td>
<td>上述你进行签名的时候使用的时间值</td>
</tr>
<tr>
<td>appKey</td>
<td>1TEST123456781</td>
<td>AK值</td>
</tr>
<tr>
<td>sign</td>
<td>A90E66763793BDBC817CF3B52AAAC041</td>
<td>上述得到的签名值</td>
</tr>
<tr>
<td>version</td>
<td>1.0.0</td>
<td>固定默认值</td>
</tr>
<tr>
<td>签名插件会默认过滤5分钟之后的请求。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>现在直奔单元测试类，把现有的时间戳，appkey 和 sign 改写成自己的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SignService signService;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> ServerWebExchange exchange;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//这里改成自己的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String appKey = <span class="string">"E841FEDBF8EE4912878993EC84F70947"</span>;</span><br><span class="line">   <span class="comment">//这里改成自己的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String secretKey = <span class="string">"4FBB99E1B97B45D79D8F891D45DBB97E"</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> SoulContext passed;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;soul.sign.delay:5&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> delay;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.signService = <span class="keyword">new</span> DefaultSignService();</span><br><span class="line">       <span class="keyword">this</span>.exchange = MockServerWebExchange.from(MockServerHttpRequest.get(<span class="string">"localhost"</span>).build());</span><br><span class="line">       <span class="comment">//这里改成自己的，路径是默认签名的一部分</span></span><br><span class="line">       <span class="keyword">final</span> String path = <span class="string">"/dubbo/findAll"</span>;</span><br><span class="line">       PluginData signData = <span class="keyword">new</span> PluginData();</span><br><span class="line">       signData.setId(<span class="string">"1"</span>);</span><br><span class="line">       signData.setName(PluginEnum.SIGN.getName());</span><br><span class="line">       signData.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">       signData.setRole(<span class="number">1</span>);</span><br><span class="line">       BaseDataCache.getInstance().cachePluginData(signData);</span><br><span class="line">       </span><br><span class="line">       AppAuthData authData = <span class="keyword">new</span> AppAuthData();</span><br><span class="line">       authData.setAppKey(appKey);</span><br><span class="line">       authData.setAppSecret(secretKey);</span><br><span class="line">       authData.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">       AuthPathData authPathData = <span class="keyword">new</span> AuthPathData();</span><br><span class="line">       authPathData.setAppName(<span class="string">"test-api"</span>);</span><br><span class="line">       authPathData.setPath(path);</span><br><span class="line">       authPathData.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">       authData.setPathDataList(Lists.newArrayList(authPathData));</span><br><span class="line">       SignAuthDataCache.getInstance().cacheAuthData(authData);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">this</span>.passed = <span class="keyword">new</span> SoulContext();</span><br><span class="line">       <span class="keyword">this</span>.passed.setModule(<span class="string">"/dubbo"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setMethod(<span class="string">"/findAll"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setRpcType(<span class="string">"dubbo"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setHttpMethod(<span class="string">"GET"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setPath(path);</span><br><span class="line">       <span class="keyword">final</span> String timestamp = String.valueOf(System.currentTimeMillis());</span><br><span class="line">       <span class="keyword">this</span>.passed.setTimestamp(timestamp);</span><br><span class="line">       <span class="keyword">this</span>.passed.setSign(buildSign(secretKey, timestamp, <span class="keyword">this</span>.passed.getPath()));</span><br><span class="line">       <span class="comment">//在这里打断点，获取到 this.getpassed 中的sign</span></span><br><span class="line">       <span class="keyword">this</span>.passed.setAppKey(appKey);</span><br><span class="line">       <span class="keyword">this</span>.passed.setContextPath(<span class="string">"/"</span>);</span><br><span class="line">       <span class="keyword">this</span>.passed.setRealUrl(<span class="string">"/dubbo/findAll"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们在postman 请求的 headers 中添加签名相关的header并请求：<br><img src="https://img-blog.csdnimg.cn/20210119012826823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功通过了校验。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type Default sign service.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoyu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSignService</span> <span class="keyword">implements</span> <span class="title">SignService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以自定义sign过期时间，单位为分钟</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;soul.sign.delay:5&#125;"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> delay;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pair&lt;Boolean, String&gt; <span class="title">signVerify</span><span class="params">(<span class="keyword">final</span> ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        PluginData signData = BaseDataCache.getInstance().obtainPluginData(PluginEnum.SIGN.getName());</span><br><span class="line">        <span class="comment">//需要配置 sign 插件且 sign 插件是激活状态</span></span><br><span class="line">        <span class="keyword">if</span> (signData != <span class="keyword">null</span> &amp;&amp; signData.getEnabled()) &#123;</span><br><span class="line">            <span class="keyword">final</span> SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);</span><br><span class="line">            <span class="keyword">assert</span> soulContext != <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//执行verify方法校验签名</span></span><br><span class="line">            <span class="keyword">return</span> verify(soulContext, exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pair.of(Boolean.TRUE, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Pair&lt;Boolean, String&gt; <span class="title">verify</span><span class="params">(<span class="keyword">final</span> SoulContext soulContext, <span class="keyword">final</span> ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//任意为空，则失败</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(soulContext.getAppKey())</span><br><span class="line">                || StringUtils.isBlank(soulContext.getSign())</span><br><span class="line">                || StringUtils.isBlank(soulContext.getTimestamp())) &#123;</span><br><span class="line">            log.error(<span class="string">"sign parameters are incomplete,&#123;&#125;"</span>, soulContext);</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_PARAMS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前的时间戳</span></span><br><span class="line">        <span class="keyword">final</span> LocalDateTime start = DateUtils.formatLocalDateTimeFromTimestampBySystemTimezone(Long.parseLong(soulContext.getTimestamp()));</span><br><span class="line">        <span class="keyword">final</span> LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> between = DateUtils.acquireMinutesBetween(start, now);</span><br><span class="line">        <span class="comment">//跟delay做比对</span></span><br><span class="line">        <span class="keyword">if</span> (between &gt; delay) &#123;</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, String.format(SoulResultEnum.SING_TIME_IS_TIMEOUT.getMsg(), delay));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign(soulContext, exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * verify sign .</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> soulContext &#123;<span class="doctag">@linkplain</span> SoulContext&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result : True is pass, False is not pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Pair&lt;Boolean, String&gt; <span class="title">sign</span><span class="params">(<span class="keyword">final</span> SoulContext soulContext, <span class="keyword">final</span> ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AppAuthData appAuthData = SignAuthDataCache.getInstance().obtainAuthData(soulContext.getAppKey());</span><br><span class="line">        <span class="comment">//一系列判空逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(appAuthData) || !appAuthData.getEnabled()) &#123;</span><br><span class="line">            log.error(<span class="string">"sign APP_kEY does not exist or has been disabled,&#123;&#125;"</span>, soulContext.getAppKey());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_APP_KEY_IS_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;AuthPathData&gt; pathDataList = appAuthData.getPathDataList();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(pathDataList)) &#123;</span><br><span class="line">            log.error(<span class="string">"You have not configured the sign path:&#123;&#125;"</span>, soulContext.getAppKey());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_PATH_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">//查看path是否在配置列表中</span></span><br><span class="line">        <span class="keyword">boolean</span> match = pathDataList.stream().filter(AuthPathData::getEnabled)</span><br><span class="line">                .anyMatch(e -&gt; PathMatchUtils.match(e.getPath(), soulContext.getPath()));</span><br><span class="line">        <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">            log.error(<span class="string">"You have not configured the sign path:&#123;&#125;,&#123;&#125;"</span>, soulContext.getAppKey(), soulContext.getRealUrl());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_PATH_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        String sigKey = SignUtils.generateSign(appAuthData.getAppSecret(), buildParamsMap(soulContext));</span><br><span class="line">        <span class="keyword">boolean</span> result = Objects.equals(sigKey, soulContext.getSign());</span><br><span class="line">        <span class="comment">//校验sign是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            log.error(<span class="string">"the SignUtils generated signature value is:&#123;&#125;,the accepted value is:&#123;&#125;"</span>, sigKey, soulContext.getSign());</span><br><span class="line">            <span class="keyword">return</span> Pair.of(Boolean.FALSE, Constants.SIGN_VALUE_IS_ERROR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;AuthParamData&gt; paramDataList = appAuthData.getParamDataList();</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(paramDataList)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Pair.of(Boolean.TRUE, <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            paramDataList.stream().filter(p -&gt;</span><br><span class="line">                    (<span class="string">"/"</span> + p.getAppName()).equals(soulContext.getContextPath()))</span><br><span class="line">                    .map(AuthParamData::getAppParam)</span><br><span class="line">                    .filter(StringUtils::isNoneBlank).findFirst()</span><br><span class="line">                    .ifPresent(param -&gt; exchange.getRequest().mutate().headers(httpHeaders -&gt; httpHeaders.set(Constants.APP_PARAM, param)).build()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pair.of(Boolean.TRUE, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">buildParamsMap</span><span class="params">(<span class="keyword">final</span> SoulContext dto)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(<span class="number">3</span>);</span><br><span class="line">        map.put(Constants.TIMESTAMP, dto.getTimestamp());</span><br><span class="line">        map.put(Constants.PATH, dto.getPath());</span><br><span class="line">        map.put(Constants.VERSION, <span class="string">"1.0.0"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实签名插件的核心逻辑比较简单，就是实现了 sign 、 verify等方法，再实现 SignService 接口的 signVerify函数完成整个签名的流程。如果有需要我们可以加入自己的签名校验逻辑，比如用JWT之类的来实现，只需要实现 SignService 接口的 signVerify 即可。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（五）Spring Cloud 插件（一）</title>
    <url>/2021/01/19/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89Spring-Cloud-%E6%8F%92%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇文章中我们学习了 sign 插件是如何实现请求鉴权的，今天我们来试试 Soul 的Spring Cloud 插件。</p>
<a id="more"></a>
<h2 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h2><p>先解除soul-bootstrap Spring Cloud 依赖部分的如下注释：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!--soul springCloud plugin start--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dromara<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>soul-spring-boot-starter-plugin-springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--soul springCloud plugin start end--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- springCloud if you config register center is nacos please dependency this--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- springCloud if you config register center is eureka please dependency end--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Cloud 插件支持 Nacos 或者 Eureka作为服务注册中的，这一次我们选择Eureka。</p>
<p>在 soul-bootstrap 的 application.yml 中添加Eureka 相关依赖：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在 soul-admin 中开启Spring Cloud 插件支持。<br><img src="https://img-blog.csdnimg.cn/20210119224248721.png" alt="在这里插入图片描述"><br>直接启动 soul-examples-springcloud 和 soul-examples-eureka，打开Eureka的页面可以看到已经把我们的应用注册好了。<br><img src="https://img-blog.csdnimg.cn/2021011922585019.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再回到 soul-admin，发现我们的 Spring Cloud 服务的相关 endpoints 已经加到了选择器和规则列表中：<br><img src="https://img-blog.csdnimg.cn/20210119230144991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们用 curl 来测试下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ curl &quot;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;hello world spring cloud findById&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>成功返回数据。现在我们使用wrk执行一下压测，以下是不适用soul网关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ wrk -t8 -c200 -d30s --latency  &quot;http:&#x2F;&#x2F;localhost:8884&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">Running 30s test @ http:&#x2F;&#x2F;localhost:8884&#x2F;order&#x2F;findById?id&#x3D;1</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency     8.21ms    6.05ms 155.20ms   92.54%</span><br><span class="line">    Req&#x2F;Sec     2.95k   703.14    15.51k    79.58%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    7.27ms</span><br><span class="line">     75%    9.19ms</span><br><span class="line">     90%   11.65ms</span><br><span class="line">     99%   33.06ms</span><br><span class="line">  700305 requests in 30.07s, 119.00MB read</span><br><span class="line">Requests&#x2F;sec:  23285.91</span><br><span class="line">Transfer&#x2F;sec:      3.96MB</span><br></pre></td></tr></table></figure>
<p>使用soul网关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ wrk -t8 -c200 -d30s --latency  &quot;http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">Running 30s test @ http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency    47.59ms   37.60ms 294.45ms   80.29%</span><br><span class="line">    Req&#x2F;Sec   592.92    129.17     0.97k    70.40%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   36.84ms</span><br><span class="line">     75%   61.51ms</span><br><span class="line">     90%   99.43ms</span><br><span class="line">     99%  176.76ms</span><br><span class="line">  141697 requests in 30.10s, 28.13MB read</span><br><span class="line">Requests&#x2F;sec:   4707.18</span><br><span class="line">Transfer&#x2F;sec:      0.93MB</span><br></pre></td></tr></table></figure>
<p>可能跟笔者机器有关，网关在8个线程200个连接测试30秒的情况，延迟有比较明显的提升，初步怀疑受到了日志输出的影响，调整日志输出级别后再进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ wrk -t8 -c200 -d30s --latency  &quot;http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1&quot;</span><br><span class="line">Running 30s test @ http:&#x2F;&#x2F;localhost:9195&#x2F;springcloud&#x2F;order&#x2F;findById?id&#x3D;1</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">^C  Thread Stats   Avg      Stdev     Max   +&#x2F;- Stdev</span><br><span class="line">    Latency    39.94ms   26.08ms 218.19ms   71.90%</span><br><span class="line">    Req&#x2F;Sec   657.54    122.81     0.91k    78.91%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   35.04ms</span><br><span class="line">     75%   53.40ms</span><br><span class="line">     90%   74.22ms</span><br><span class="line">     99%  122.25ms</span><br><span class="line">  33581 requests in 6.44s, 6.67MB read</span><br><span class="line">Requests&#x2F;sec:   5214.23</span><br><span class="line">Transfer&#x2F;sec:      1.04MB</span><br></pre></td></tr></table></figure>
<p>设置日志输出级别为error后性能损耗要小一些。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
  <entry>
    <title>Soul 网关源码分析（六）使用websocket同步数据到网关</title>
    <url>/2021/01/21/Soul-%E7%BD%91%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E4%BD%BF%E7%94%A8websocket%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>Soul 提供了多种数据同步的策略，默认且推荐的方式是使用 websocket。为了追求极致的响应速度，所有的配置没有选择存到redis，MySQL或是其他存储方式中，而是直接在HashMap中缓存，可以达到极低的延迟。</p>
<a id="more"></a>
<p>下图是三种策略下，Soul 网关与 soul-admin 数据同步的流程：<br><img src="https://img-blog.csdnimg.cn/20210121001006462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpY2tlZFdpbmdz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>借助websocket的特性，DataChangedEventDispatcher 得以主动向 Soul 网关推送数据变更。当 soul-admin 与 soul-bootstrap 首次建立连接时，会向soul-bootstrap 推送一次全量的配置数据，增量的数据也可以由 soul-admin 主动推送给 soul-bootstrap。</p>
<p>soul-admin 会根据配置加载以下的 bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The WebsocketListener(default strategy).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"soul.sync.websocket.enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(WebsocketSyncProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">WebsocketListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听数据变化的listener.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the data changed listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(WebsocketDataChangedListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataChangedListener</span> <span class="title">websocketDataChangedListener</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebsocketDataChangedListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket服务端，负责websocket 数据的 OnOpen，OnMessage，OnClose，OnError等生命周期的处理和数据推送。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the websocket collector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(WebsocketCollector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">WebsocketCollector</span> <span class="title">websocketCollector</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebsocketCollector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server endpoint exporter server endpoint exporter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the server endpoint exporter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(ServerEndpointExporter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ServerEndpointExporter</span> <span class="title">serverEndpointExporter</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，WebsocketDataChangedListener 封装了对一系列数据的监听，以插件变更监听为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPluginChanged</span><span class="params">(<span class="keyword">final</span> List&lt;PluginData&gt; pluginDataList, <span class="keyword">final</span> DataEventTypeEnum eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先封装 websocket 数据，再使用 WebsocketCollector 来发送json序列化后的数据到 soul-bootstrap.</span></span><br><span class="line">    WebsocketData&lt;PluginData&gt; websocketData =</span><br><span class="line">            <span class="keyword">new</span> WebsocketData&lt;&gt;(ConfigGroupEnum.PLUGIN.name(), eventType.name(), pluginDataList);</span><br><span class="line">    WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type Websocket data changed listener.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoyu(Myth)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huangxiaofeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketCollector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Session&gt; SESSION_SET = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SESSION_KEY = <span class="string">"sessionKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 略 **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * On message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message the message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session the session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">final</span> String message, <span class="keyword">final</span> Session session)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 只有 message 的类型是 MYSELF时才处理</span></span><br><span class="line">        <span class="keyword">if</span> (message.equals(DataEventTypeEnum.MYSELF.name())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//将 websocket session 保存到 ThreadLocal 中。</span></span><br><span class="line">                ThreadLocalUtil.put(SESSION_KEY, session);</span><br><span class="line">                </span><br><span class="line">                SpringBeanUtils.getInstance().getBean(SyncDataService<span class="class">.<span class="keyword">class</span>).<span class="title">syncAll</span>(<span class="title">DataEventTypeEnum</span>.<span class="title">MYSELF</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalUtil.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message the message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type    the type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String message, <span class="keyword">final</span> DataEventTypeEnum type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(message)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DataEventTypeEnum.MYSELF == type) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        session.getBasicRemote().sendText(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"websocket send result is exception: "</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向所有存在的session 发送消息</span></span><br><span class="line">            <span class="keyword">for</span> (Session session : SESSION_SET) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"websocket send result is exception: "</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到当 DataEventTypeEnum 是 MYSELF 时，也就是客户端发来 MYSELF 消息时，服务端会把所有的配置数据同步给客户端，具体的代码实现在 WebsocketSyncDataConfiguration 这个类加载、创建 WebsocketSyncDataService bean 时，在 WebsocketSyncDataService 类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketSyncDataService</span> <span class="keyword">implements</span> <span class="title">SyncDataService</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;WebSocketClient&gt; clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor executor;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WebsocketSyncDataService</span><span class="params">(<span class="keyword">final</span> WebsocketConfig websocketConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                    <span class="keyword">final</span> PluginDataSubscriber pluginDataSubscriber,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                    <span class="keyword">final</span> List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                    <span class="keyword">final</span> List&lt;AuthDataSubscriber&gt; authDataSubscribers)</span> </span>&#123;</span><br><span class="line">	        String[] urls = StringUtils.split(websocketConfig.getUrls(), <span class="string">","</span>);</span><br><span class="line">	        executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(urls.length, SoulThreadFactory.create(<span class="string">"websocket-connect"</span>, <span class="keyword">true</span>));</span><br><span class="line">	        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	            	<span class="comment">//遍历所有url，将 SoulWebsocketClient 实例加到 clients中</span></span><br><span class="line">	                clients.add(<span class="keyword">new</span> SoulWebsocketClient(<span class="keyword">new</span> URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">	                log.error(<span class="string">"websocket url(&#123;&#125;) is error"</span>, url, e);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">        <span class="comment">/** 略 **/</span></span><br></pre></td></tr></table></figure>
<p>而在实例化 SoulWebsocketClient时，会调用如下的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="keyword">final</span> ServerHandshake serverHandshake)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!alreadySync) &#123;</span><br><span class="line">         send(DataEventTypeEnum.MYSELF.name());</span><br><span class="line">         alreadySync = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>client会在 websocket open 的时候 发送 MYSELF 消息到服务端，验证了上面我们的想法。其他类型的 DataEventTypeEnum 发送则是通过 onMessage 处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>soul 巧妙得运用了 websocket 进行数据同步，将数据直接放到JVM的方法也体现了对性能的极致追求。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Soul</tag>
      </tags>
  </entry>
</search>
